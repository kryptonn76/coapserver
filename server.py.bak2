#!/usr/bin/env python3
"""
Serveur CoAP pour contr√¥ler les nodes ESP32 OpenThread
Version avec socket UDP simple qui fonctionne sur macOS
Int√©gration ThingsBoard pour la t√©l√©m√©trie des batteries
Int√©gration WebSocket pour recevoir les mises √† jour de t√©l√©m√©trie en temps r√©el
Cartographie automatique du r√©seau OpenThread
"""

import socket
import struct
import json
import time
import threading
import queue
from datetime import datetime
from pathlib import Path
from collections import deque
import os
import requests
from dotenv import load_dotenv

# Import ThingsBoard (optionnel)
try:
    from tb_rest_client.rest_client_ce import RestClientCE
    from tb_rest_client.rest import ApiException
    TB_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è  Module tb_rest_client non disponible - ThingsBoard d√©sactiv√©")
    RestClientCE = None
    ApiException = None
    TB_AVAILABLE = False

from flask import Flask, render_template, jsonify, request
from flask_socketio import SocketIO, emit
from flask_cors import CORS
from flask_sock import Sock
import logging

# Import ThingsBoard Location Tracker (optionnel)
try:
    from lib.thingsboard_loc_tracker import ThingsBoardLocTracker
except ImportError as e:
    print(f"‚ö†Ô∏è  Module thingsboard_loc_tracker non disponible: {e}")
    ThingsBoardLocTracker = None

import asyncio
from lib.network_topology import NetworkTopology
from lib.ot_network_mapper import OpenThreadScanner

# Import audio library
from lib.audio_library import audio_lib

# Import Border Router Management
from lib.border_router_manager import BorderRouterManager
from lib.br_auth import verify_br_token, get_br_config, get_br_nodes
import uuid

# Import nouveaux modules refactoris√©s
from lib.registry import NodeRegistry
from lib.thingsboard_client import ThingsBoardClient
from lib.tracking.badge_tracker import BadgeTracker
from lib.coap.client import CoAPClient
from lib.coap.protocol import parse_coap_packet, create_coap_response

# Charger les variables d'environnement
load_dotenv()

# Configuration
COAP_PORT = 5683
ADDRESSES_FILE = "config/adresses.json"
WEB_PORT = 5001

# Border Router WebSocket Configuration
USE_WEBSOCKET_BR = os.getenv('USE_WEBSOCKET_BR', 'false').lower() == 'true'
BR_AUTH_ENABLED = os.getenv('BR_AUTH_ENABLED', 'true').lower() == 'true'
BR_HEARTBEAT_TIMEOUT = int(os.getenv('BR_HEARTBEAT_TIMEOUT', '30'))

# Log configuration at startup
print("=" * 60)
print("üîß CONFIGURATION BORDER ROUTER WEBSOCKET")
print("=" * 60)
print(f"USE_WEBSOCKET_BR:     {USE_WEBSOCKET_BR}")
print(f"BR_AUTH_ENABLED:      {BR_AUTH_ENABLED}")
print(f"BR_HEARTBEAT_TIMEOUT: {BR_HEARTBEAT_TIMEOUT}s")
print("=" * 60)

# Flask app
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key-for-demo'
CORS(app)
# Socket.IO pour les clients web (navigateur)
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading',
                    logger=True, engineio_logger=True)
print(f"üîç socketio id @init: {id(socketio)}, module: {__name__}")
sock = Sock(app)  # Native WebSocket support for Border Routers

# Queue thread-safe pour √©missions SocketIO depuis threads externes
# Cela √©vite le blocage des √©missions quand le serveur Flask est occup√©
socketio_queue = queue.Queue(maxsize=200)  # Buffer jusqu'√† 200 √©v√©nements
socketio_queue_running = True

def socketio_emit_worker():
    """Thread worker qui consomme la queue et √©met les √©v√©nements SocketIO

    Ce thread tourne dans le contexte Flask et peut √©mettre en continu
    sans √™tre bloqu√© par les threads externes (CoAP, etc.)
    """
    print(f"üîÑ [SOCKETIO-WORKER] Thread d√©marr√©, en attente d'√©v√©nements...")
    while socketio_queue_running:
        try:
            # Attendre un √©v√©nement (timeout 0.5s pour v√©rifier periodiquement le flag)
            event_name, event_data = socketio_queue.get(timeout=0.5)

            t_dequeue = time.time()
            print(f"üì§ [SOCKETIO-WORKER] Dequeue √©v√©nement '{event_name}' √† {t_dequeue:.3f}")

            # IMPORTANT: √âmettre dans le contexte Flask pour que SocketIO fonctionne
            with app.app_context():
                socketio.emit(event_name, event_data)

            t_emit = time.time()
            emit_delay_ms = (t_emit - t_dequeue) * 1000
            print(f"‚úÖ [SOCKETIO-WORKER] √âmission '{event_name}' termin√©e en {emit_delay_ms:.1f}ms (to all clients)")

            socketio_queue.task_done()
        except queue.Empty:
            # Pas d'√©v√©nement, continuer la boucle
            continue
        except Exception as e:
            print(f"‚ùå Erreur √©mission SocketIO worker: {e}")

# Lancer le worker thread au d√©marrage du module
socketio_worker_thread = threading.Thread(target=socketio_emit_worker, daemon=True)
socketio_worker_thread.start()

# R√©duire les logs Flask
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

# Configuration ThingsBoard
TB_CONFIG = {
    'url': os.getenv('TB_URL', 'https://platform.tamtamdeals.com'),
    'username': os.getenv('TB_USERNAME', ''),
    'password': os.getenv('TB_PASSWORD', '')
}

# NodeRegistry maintenant import√© depuis lib/registry.py
# ThingsBoardClient maintenant import√© depuis lib/thingsboard_client.py

class BadgeTracker:
    """Tracks badge code sequences for quality control (po1‚Üípo2‚Üí...‚Üípo0‚Üípo1)"""

    def __init__(self, addr):
        self.addr = addr
        self.last_code = None
        self.last_timestamp = 0
        self.sequence_errors = 0  # Counter for sequence gaps
        self.total_expected = 0   # Total frames expected since first seen
        self.first_seen = time.time()

    def check_sequence(self, new_code, timestamp):
        """Check sequence continuity po1‚Üípo2‚Üí...‚Üípo0‚Üípo1

        Returns:
            (is_valid, gap): is_valid=True if sequence correct, gap=number of missed frames
        """
        if self.last_code is None:
            # First frame
            self.last_code = new_code
            self.last_timestamp = timestamp
            self.total_expected = 1
            return (True, 0)

        # Calculate expected code
        last_digit = int(self.last_code[2])
        if last_digit == 9:
            expected_digit = 0
        elif last_digit == 0:
            expected_digit = 1
        else:
            expected_digit = last_digit + 1

        expected_code = f"po{expected_digit}"

        # Calculate gap
        gap = 0
        if new_code != expected_code:
            gap = self._calculate_gap(self.last_code, new_code)
            self.sequence_errors += gap

        # Update state
        self.last_code = new_code
        self.last_timestamp = timestamp
        self.total_expected += (gap + 1)  # Add gap + this frame

        return (new_code == expected_code, gap)

    def _calculate_gap(self, old_code, new_code):
        """Calculate number of missed frames between old_code and new_code"""
        old_digit = int(old_code[2])
        new_digit = int(new_code[2])

        # Map to sequence index: po1=1, po2=2, ..., po9=9, po0=10
        old_idx = old_digit if old_digit != 0 else 10
        new_idx = new_digit if new_digit != 0 else 10

        # Calculate gap with wraparound (cycle of 10)
        if new_idx > old_idx:
            gap = new_idx - old_idx - 1
        else:
            gap = (10 - old_idx) + new_idx - 1

        return gap if gap > 0 else 0

    def get_stats(self):
        """Get tracking statistics"""
        runtime = time.time() - self.first_seen
        received = self.total_expected - self.sequence_errors
        success_rate = 100.0 * received / self.total_expected if self.total_expected > 0 else 0

        return {
            'addr': self.addr,
            'runtime_sec': runtime,
            'total_expected': self.total_expected,
            'received': received,
            'missed': self.sequence_errors,
            'success_rate': success_rate,
            'last_code': self.last_code
        }

class CoAPServer:
    """Serveur CoAP avec socket UDP simple et int√©gration ThingsBoard WebSocket"""
    
    def __init__(self):
        self.registry = NodeRegistry()
        self.running = False
        self.sock = None
        self.event_count = 0
        self.demo_mode = False
        self.battery_status = {}  # Stockage de l'√©tat batterie par node
        self.ble_detections = {}  # Stockage des d√©tections BLE beacon {code: {addr, rssi, timestamp, node}}
        self.ble_multi_detections = {}  # D√©tections multi-routeurs {badge_addr: [{node, rssi, timestamp}, ...]}
        self.badge_positions = {}  # Positions calcul√©es des badges {badge_addr: {x, y, confidence, timestamp}}
        self.node_positions = {}  # Positions des routeurs {node_name: {x, y}}
        self.name_to_rloc16 = {}  # Mapping nom‚ÜíRLOC16 (ex: "n01" ‚Üí "0x1800")
        self.ble_cache = {}  # Cache de d√©duplication globale {addr_code: timestamp}
        self.ble_history = []  # Historique complet des d√©tections pour la page web
        self.thingsboard = ThingsBoardClient(
            on_telemetry_update=self.handle_tb_telemetry_update,
            on_location_change=self.handle_location_change
        )  # Client ThingsBoard avec callbacks
        self.led_states = {}  # √âtat des LEDs par node
        self.button_events = deque(maxlen=100)  # Historique des √©v√©nements boutons
        self.node_status = {}  # √âtat g√©n√©ral des nodes
        self.tracking_mode = False  # Mode suivi de position
        self.current_tracking_node = None  # Node actuellement active en mode suivi

        # Badge sequence tracking for quality control
        self.badge_trackers = {}  # {ble_addr: BadgeTracker}

    def parse_coap_packet(self, data):
        """Parse basique d'un paquet CoAP"""
        if len(data) < 4:
            return None
            
        # Header CoAP
        byte0 = data[0]
        version = (byte0 >> 6) & 0x03
        msg_type = (byte0 >> 4) & 0x03
        token_length = byte0 & 0x0F
        
        code = data[1]
        message_id = struct.unpack('!H', data[2:4])[0]
        
        # Code CoAP
        code_class = code >> 5
        code_detail = code & 0x1F
        
        # Skip token
        offset = 4 + token_length
        
        # Parser les options pour trouver l'URI path
        uri_path = []
        payload = b''
        option_number = 0
        
        while offset < len(data):
            if data[offset] == 0xFF:  # Marqueur de fin des options
                offset += 1
                if offset < len(data):
                    payload = data[offset:]
                break
                
            # Parser l'option
            byte = data[offset]
            option_delta = (byte >> 4) & 0x0F
            option_length = byte & 0x0F
            offset += 1
            
            # G√©rer les deltas/longueurs √©tendus (simplifi√©)
            if option_delta == 13:
                option_delta = 13 + data[offset]
                offset += 1
            elif option_delta == 14:
                option_delta = 269 + struct.unpack('!H', data[offset:offset+2])[0]
                offset += 2
                
            if option_length == 13:
                option_length = 13 + data[offset]
                offset += 1
            elif option_length == 14:
                option_length = 269 + struct.unpack('!H', data[offset:offset+2])[0]
                offset += 2
                
            option_number += option_delta
            
            # Extraire la valeur de l'option
            if offset + option_length <= len(data):
                option_value = data[offset:offset + option_length]
                offset += option_length
                
                # Option 11 = Uri-Path
                if option_number == 11:
                    uri_path.append(option_value.decode('utf-8', errors='ignore'))
            else:
                break
                    
        return {
            'version': version,
            'type': msg_type,
            'code': f"{code_class}.{code_detail:02d}",
            'message_id': message_id,
            'uri_path': '/'.join(uri_path),
            'payload': payload,
            'token_length': token_length
        }
    
    def create_coap_response(self, message_id, code=0x45):  # 2.05 Content
        """Cr√©e une r√©ponse CoAP ACK"""
        header = struct.pack('!BBH', 
                            0x60,  # Ver=1, Type=2 (ACK), TKL=0
                            code,  # 2.05 Content
                            message_id)
        return header + b'\xff' + b'ok'  # Payload marker + contenu
    
    def create_coap_post_packet(self, uri_path, payload):
        """Cr√©e un paquet CoAP POST (helper pour √©viter les logs)"""
        message_id = int(time.time()) % 0xFFFF
        header = struct.pack('!BBH',
                            0x50,  # Ver=1, Type=NON, TKL=0
                            0x02,  # Code=POST (0.02)
                            message_id)
        
        # Option Uri-Path
        uri_bytes = uri_path.encode('utf-8')
        option_header = bytes([0xB0 + len(uri_bytes)])  # Delta=11
        
        # Construire le paquet
        return header + option_header + uri_bytes + b'\xff' + payload.encode('utf-8')
    
    def send_coap_post(self, address, uri_path, payload):
        """Envoie un POST CoAP √† une adresse"""
        try:
            # Cr√©er un nouveau socket pour l'envoi
            sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)

            # Header CoAP POST
            message_id = int(time.time()) % 0xFFFF
            header = struct.pack('!BBH',
                                0x50,  # Ver=1, Type=NON, TKL=0
                                0x02,  # Code=POST (0.02)
                                message_id)

            # Option Uri-Path
            uri_bytes = uri_path.encode('utf-8')
            option_header = bytes([0xB0 + len(uri_bytes)])  # Delta=11

            # Construire le paquet
            packet = header + option_header + uri_bytes + b'\xff' + payload.encode('utf-8')

            # Envoyer
            sock.sendto(packet, (address, COAP_PORT))
            print(f"‚úÖ Envoy√© '{payload}' √† {address}/{uri_path}")

            sock.close()
            return True

        except Exception as e:
            print(f"‚ùå Erreur envoi CoAP: {e}")
            return False

    def send_command_via_br(self, node_name, command_type, payload=None):
        """
        Envoie une commande √† un node via le Border Router en mode WebSocket

        Args:
            node_name: Nom du node cible (ex: "n01")
            command_type: Type de commande (audio_play, audio_stop, audio_volume, led_control, led_blink)
            payload: Payload de la commande (dict)

        Returns:
            tuple: (success: bool, request_id: str ou None, error: str ou None)
        """
        # Trouver le BR qui g√®re ce node
        br_id = border_router_manager.get_br_for_node(node_name)
        if not br_id:
            error_msg = f"Aucun Border Router online ne g√®re le node {node_name}"
            logger.warning(error_msg)
            return False, None, error_msg

        # G√©n√©rer un request_id unique
        request_id = str(uuid.uuid4())

        # Construire le message de commande selon le protocole
        command_data = {
            'command': command_type,  # Renamed from 'type' to 'command' for clarity
            'target_node': node_name,
            'request_id': request_id,
            'payload': payload or {}
        }

        # Envoyer via WebSocket natif au BR
        try:
            success = native_ws_handler.send_command(br_id, command_data)

            if success:
                logger.info(f"üì§ Commande {command_type} envoy√©e au BR {br_id} pour node {node_name} (request_id: {request_id})")

                # Incr√©menter le compteur de commandes
                border_router_manager.increment_command_counter(br_id)

                return True, request_id, None
            else:
                error_msg = f"BR {br_id} non connect√© ou erreur d'envoi"
                return False, None, error_msg

        except Exception as e:
            error_msg = f"Erreur envoi commande via BR: {e}"
            logger.error(error_msg)
            return False, None, error_msg

    def handle_button_event_from_br(self, data):
        """
        Traite un √©v√©nement bouton re√ßu depuis un Border Router

        Args:
            data: Donn√©es de l'√©v√©nement (contient br_id, node, payload, timestamp)
        """
        br_id = data.get('br_id')
        node_name = data.get('node')
        payload = data.get('payload', {})

        logger.info(f"üîò √âv√©nement bouton depuis BR {br_id}, node {node_name}: {payload}")

        # Extraire les informations du payload
        state = payload.get('state', 'pressed')
        duration_ms = payload.get('duration_ms', 0)

        # Cr√©er l'√©v√©nement pour le web
        event_data = {
            'node': node_name,
            'br_id': br_id,
            'timestamp': datetime.now().isoformat(),
            'type': 'button',
            'state': state,
            'duration_ms': duration_ms
        }

        # D√©tecter si c'est un long press (> 2 secondes)
        if duration_ms > 2000:
            logger.info(f"üîòüîò BOUTON LONG PRESS d√©tect√© (node {node_name}, {duration_ms}ms)")
            event_data['action'] = 'longpress'

            # TODO: Impl√©menter la logique de toggle global des LEDs via WebSocket
            # Pour l'instant on √©met juste l'√©v√©nement

        # √âmettre l'√©v√©nement WebSocket
        socketio.emit('button_event', event_data)
        self.button_events.append(event_data)

        # Incr√©menter le compteur d'√©v√©nements du BR
        border_router_manager.increment_event_counter(br_id)

    def handle_battery_event_from_br(self, data):
        """
        Traite un √©v√©nement batterie re√ßu depuis un Border Router

        Args:
            data: Donn√©es de l'√©v√©nement (contient br_id, node, payload, timestamp)
        """
        br_id = data.get('br_id')
        node_name = data.get('node')
        payload = data.get('payload', {})

        voltage = payload.get('voltage', 0)
        percentage = payload.get('percentage', 0)

        logger.info(f"üîã Batterie depuis BR {br_id}, node {node_name}: {voltage}V ({percentage}%)")

        # Stocker l'√©tat batterie
        self.battery_status[node_name] = {
            'voltage': voltage,
            'percentage': percentage,
            'timestamp': datetime.now().isoformat(),
            'br_id': br_id
        }

        # √âmettre via WebSocket
        socketio.emit('battery_update', {
            'node': node_name,
            'voltage': voltage,
            'percentage': percentage,
            'timestamp': datetime.now().isoformat()
        })

        # Incr√©menter le compteur d'√©v√©nements du BR
        border_router_manager.increment_event_counter(br_id)

    def handle_ble_event_from_br(self, data):
        """
        Traite un √©v√©nement BLE beacon re√ßu depuis un Border Router

        Args:
            data: Donn√©es de l'√©v√©nement (contient br_id, node, payload, timestamp)
        """
        br_id = data.get('br_id')
        node_name = data.get('node')
        payload = data.get('payload', {})

        # R√©cup√©rer l'adresse BLE et le RSSI depuis le payload
        ble_addr = payload.get('ble_addr', '')
        rssi = payload.get('rssi', 0)
        code = payload.get('code', '')

        print(f"üì° BLE beacon depuis BR {br_id}, node {node_name}: {ble_addr} (RSSI: {rssi}, code: {code})")

        # Stocker la d√©tection
        detection_data = {
            'node': node_name,
            'br_id': br_id,
            'ble_addr': ble_addr,
            'rssi': rssi,
            'code': code,
            'timestamp': datetime.now().isoformat()
        }

        # Ajouter √† l'historique
        self.ble_history.append(detection_data)

        # Limiter l'historique √† 1000 entr√©es
        if len(self.ble_history) > 1000:
            self.ble_history.pop(0)

        # Mettre √† jour le cache de d√©tection
        if code:
            self.ble_detections[code] = detection_data

        # √âmettre via WebSocket (utiliser start_background_task pour thread-safety)
        def _emit_ble_events():
            print(f"üîç socketio id @emit: {id(socketio)}, module: {__name__}")
            print(f"üì§ √âmission 'ble_beacon' et 'ble_frame' via SocketIO...")
            socketio.emit('ble_beacon', detection_data, namespace='/')
            socketio.emit('ble_frame', frame_data, namespace='/')
            print(f"‚úÖ √âv√©nements Socket.IO √©mis avec succ√®s")

        # Pr√©parer frame_data pour la page debug
        frame_data = {
            'router': node_name,
            'code': code,
            'badge_addr': ble_addr,
            'rssi': rssi if rssi else 0,
            'timestamp': datetime.now().isoformat()
        }

        # Lancer l'√©mission dans une t√¢che background Socket.IO
        socketio.start_background_task(_emit_ble_events)

        # Incr√©menter le compteur d'√©v√©nements du BR
        border_router_manager.increment_event_counter(br_id)

    def handle_button_event(self, source_addr, payload, flash_duration=2, demo_mode=False):
        """Traite un √©v√©nement bouton"""
        node_name = self.registry.get_node_by_address(source_addr)
        if not node_name:
            node_name = "unknown"
        
        # Cr√©er l'√©v√©nement pour le web
        event_data = {
            'node': node_name,
            'address': source_addr,
            'timestamp': datetime.now().isoformat(),
            'type': 'button'
        }
        
        # V√©rifier si c'est un √©v√©nement long press
        if payload and payload.startswith("longpress:"):
            # Extraire l'ID du node
            node_id = payload.split(":", 1)[1] if ":" in payload else ""
            print(f"\nüîòüîò BOUTON LONG PRESS par {node_name} ({source_addr})")
            print(f"   Node ID: {node_id}")
            
            # R√©cup√©rer l'√©tat actuel de la LED du node source
            current_state = self.led_states.get(source_addr, {}).get('light', False)
            new_state = not current_state
            
            print(f"   √âtat actuel de la LED source: {'ON' if current_state else 'OFF'}")
            print(f"   ‚Üí Toggle toutes les LEDs vers: {'ON' if new_state else 'OFF'}")
            
            # Obtenir toutes les adresses des nodes
            addresses = self.registry.get_all_addresses()
            
            # Envoyer la commande √† tous les nodes
            command = "light:on" if new_state else "light:off"
            for addr in addresses:
                self.send_coap_post(addr, "led", command)
                
                # Mettre √† jour l'√©tat local de chaque node
                if addr not in self.led_states:
                    self.led_states[addr] = {}
                self.led_states[addr]['light'] = new_state
            
            print(f"   ‚úÖ {len(addresses)} nodes synchronis√©s")
            
            event_data['action'] = 'longpress'
            event_data['node_id'] = node_id
            event_data['global_led_state'] = new_state
            
            # √âmettre l'√©v√©nement WebSocket
            socketio.emit('button_event', event_data)
            self.button_events.append(event_data)
            
            # √âmettre les mises √† jour LED pour tous les nodes
            for name, node_data in self.registry.nodes.items():
                if isinstance(node_data, dict):
                    addr = node_data.get('address')
                else:
                    addr = node_data
                
                if addr:
                    socketio.emit('led_update', {
                        'node': name,
                        'led': 'light',
                        'state': new_state
                    })
            
            return
        
        # √âv√©nement click normal
        print(f"\nüîò BOUTON PRESS√â par {node_name} ({source_addr})")
        print(f"   Payload: {payload}")
        
        event_data['action'] = 'click'
        event_data['payload'] = payload
        
        # Toggle la LED du node qui a envoy√© l'√©v√©nement
        print(f"üí° Toggle LED sur {node_name}...")
        
        # G√©rer l'√©tat de la LED pour ce node
        if not hasattr(self, 'led_states'):
            self.led_states = {}
        
        # Toggle l'√©tat
        current_state = self.led_states.get(source_addr, {}).get('light', False)
        new_state = not current_state
        
        if source_addr not in self.led_states:
            self.led_states[source_addr] = {}
        self.led_states[source_addr]['light'] = new_state
        
        # Envoyer la commande
        command = "light:on" if new_state else "light:off"
        self.send_coap_post(source_addr, "led", command)
        
        print(f"   ‚Üí LED {node_name}: {'ON' if new_state else 'OFF'}")
        
        # √âmettre l'√©v√©nement WebSocket
        event_data['led_state'] = new_state
        socketio.emit('button_event', event_data)
        self.button_events.append(event_data)
        
        # Mettre √† jour l'√©tat du node
        socketio.emit('led_update', {
            'node': node_name,
            'led': 'light',
            'state': new_state
        })
    
    def handle_server_id(self, source_addr, payload):
        """Traite une demande server-id"""
        print(f"üì° Requ√™te server-id de {source_addr}: {payload}")
        # Le node conna√Æt maintenant notre adresse
        
    def handle_battery_report(self, source_addr, payload):
        """Traite un rapport de batterie"""
        node_name = self.registry.get_node_by_address(source_addr)
        if not node_name:
            node_name = f"unknown_{source_addr[:8]}"
        
        # Parser le payload "12.45V:95"
        try:
            parts = payload.split(':')
            if len(parts) >= 2:
                voltage_str = parts[0].rstrip('V')
                percentage_str = parts[1]
                voltage = float(voltage_str)
                percentage = int(percentage_str)
                
                # Stocker l'√©tat batterie
                if node_name not in self.battery_status:
                    self.battery_status[node_name] = {
                        'history': deque(maxlen=10),  # Garder les 10 derni√®res mesures
                        'current': None
                    }
                
                battery_data = {
                    'timestamp': datetime.now(),
                    'voltage': voltage,
                    'percentage': percentage
                }
                
                self.battery_status[node_name]['current'] = battery_data
                self.battery_status[node_name]['history'].append(battery_data)
                
                # Afficher l'√©tat
                timestamp = datetime.now().strftime("%H:%M:%S")
                status_icon = "üîã" if percentage > 20 else "ü™´"
                print(f"\n{status_icon} [{timestamp}] Batterie {node_name}: {voltage:.2f}V ({percentage}%)")
                
                # Alerte si batterie faible
                if percentage < 20:
                    print(f"   ‚ö†Ô∏è  ATTENTION: Batterie faible sur {node_name}!")
                
                # √âmettre l'√©tat batterie via WebSocket
                socketio.emit('battery_update', {
                    'node': node_name,
                    'voltage': voltage,
                    'percentage': percentage,
                    'timestamp': datetime.now().isoformat(),
                    'low_battery': percentage < 20
                })
                
                # Envoyer √† ThingsBoard
                if self.thingsboard.connected:
                    self.thingsboard.send_battery_telemetry(node_name, voltage, percentage)
                    
            else:
                print(f"‚ùå Format de payload batterie invalide: {payload}")
                
        except Exception as e:
            print(f"‚ùå Erreur parsing batterie: {e} (payload: {payload})")

    def handle_ble_beacon(self, source_addr, payload):
        """Traite une d√©tection BLE beacon avec d√©duplication intelligente

        Logique:
        - Cache par balise (code+adresse) avec timeout 5s
        - Changement de code = reset du cache pour cette balise
        - Protection anti-retard: ancien code < 1s apr√®s nouveau code = ignor√©
        """
        t_receive = time.time()
        node_name = self.registry.get_node_by_address(source_addr)
        if not node_name:
            node_name = f"unknown_{source_addr[:8]}"

        try:
            # Parser le JSON payload
            data = json.loads(payload)
            code = data.get('code', '')
            ble_addr = data.get('addr', '')
            rssi = data.get('rssi', 0)
            timestamp_ms = data.get('timestamp', 0)

            print(f"üì• [COAP-RX] Trame BLE re√ßue: {code} @ {t_receive:.3f} (rssi={rssi}dBm)")

            # √âmettre TOUTES les trames pour debug (avant d√©duplication)
            # Utiliser la queue thread-safe pour √©mission depuis thread CoAP
            try:
                t_before_queue = time.time()
                socketio_queue.put_nowait(('ble_frame', {
                    'router': node_name,
                    'code': code,
                    'badge_addr': ble_addr,
                    'rssi': rssi,
                    'timestamp': datetime.now().isoformat()
                }))
                t_after_queue = time.time()
                queue_delay_us = (t_after_queue - t_before_queue) * 1000000
                queue_size = socketio_queue.qsize()
                print(f"üì® [COAP-RX] Trame {code} enqueue en {queue_delay_us:.0f}¬µs (queue={queue_size}/200)")
            except queue.Full:
                print(f"‚ö†Ô∏è Queue SocketIO pleine, trame BLE perdue")

            cache_key = f"{ble_addr}_{code}"
            now = time.time()

            # V√©rifier si on a d√©j√† vu cette balise (n'importe quel code)
            beacon_prefix = f"{ble_addr}_"
            last_code = None
            last_time = None

            for key, timestamp in list(self.ble_cache.items()):
                if key.startswith(beacon_prefix):
                    last_code = key.split('_', 1)[1]
                    last_time = timestamp

                    # Changement de code d√©tect√©
                    if last_code != code:
                        # Avec √©mission 1x/seconde, accepter les paquets m√™me en retard
                        # (pas de double √©mission BLE donc pas de risque de duplicate)
                        del self.ble_cache[key]
                        break
                    else:
                        # M√™me code re√ßu deux fois
                        time_diff = (now - last_time)
                        if time_diff < 1.0:
                            # Duplicate r√©cent, ignorer
                            return
                        else:
                            # Timeout expir√© (>1s), accepter
                            del self.ble_cache[key]
                            break

            # Mettre √† jour le cache avec le nouveau code
            self.ble_cache[cache_key] = now

            # Track sequence for quality control
            if ble_addr not in self.badge_trackers:
                self.badge_trackers[ble_addr] = BadgeTracker(ble_addr)

            tracker = self.badge_trackers[ble_addr]
            previous_code = tracker.last_code  # Save before check_sequence updates it
            is_valid, gap = tracker.check_sequence(code, now)

            # Log sequence errors (only if frames actually missed)
            if not is_valid and previous_code and gap > 0:
                print(f"‚ö†Ô∏è  Badge {ble_addr[-8:]}: Sequence break {previous_code} ‚Üí {code} "
                      f"({gap} frame{'s' if gap > 1 else ''} missed)")

            # Stocker la d√©tection actuelle
            detection_time = datetime.now()
            self.ble_detections[ble_addr] = {
                'code': code,
                'addr': ble_addr,
                'rssi': rssi,
                'timestamp': detection_time,
                'node': node_name
            }

            # Stocker dans multi-d√©tections pour triangulation (fen√™tre de 3 secondes)
            if ble_addr not in self.ble_multi_detections:
                self.ble_multi_detections[ble_addr] = []

            # Ajouter la nouvelle d√©tection
            self.ble_multi_detections[ble_addr].append({
                'node': node_name,
                'rssi': rssi,
                'timestamp': now,
                'code': code
            })

            # Nettoyer les d√©tections > 5 secondes
            self.ble_multi_detections[ble_addr] = [
                d for d in self.ble_multi_detections[ble_addr]
                if (now - d['timestamp']) < 5.0
            ]

            # Calculer et √©mettre la position du badge
            self.calculate_and_emit_badge_position(ble_addr, code)

            # Ajouter √† l'historique (limit√© aux 1000 derni√®res d√©tections)
            self.ble_history.append({
                'timestamp': detection_time.isoformat(),
                'device': ble_addr,
                'code': code,
                'node': node_name,
                'rssi': rssi
            })
            if len(self.ble_history) > 1000:
                self.ble_history.pop(0)

            # Ne plus logger dans le terminal (affichage via page web)

            # √âmettre via WebSocket
            # Utiliser la queue thread-safe pour √©mission depuis thread CoAP
            try:
                socketio_queue.put_nowait(('ble_beacon', {
                    'device': ble_addr,
                    'code': code,
                    'rssi': rssi,
                    'node': node_name,
                    'timestamp': detection_time.isoformat()
                }))
            except queue.Full:
                print(f"‚ö†Ô∏è Queue SocketIO pleine, beacon BLE perdu")

        except json.JSONDecodeError as e:
            print(f"‚ùå Erreur JSON parsing BLE beacon: {e} (payload: {payload})")
        except Exception as e:
            print(f"‚ùå Erreur parsing BLE beacon: {e} (payload: {payload})")

    def calculate_and_emit_badge_position(self, badge_addr, code):
        """Calcule la position d'un badge par triangulation RSSI et √©met via WebSocket"""
        try:
            detections = self.ble_multi_detections.get(badge_addr, [])

            # Besoin d'au moins 2 routeurs pour triangulation
            if len(detections) < 2:
                return

            # Filtrer pour garder d√©tections tr√®s r√©centes (< 1 seconde)
            # Besoin d'au moins 2 routeurs qui d√©tectent dans la m√™me seconde
            now = time.time()
            recent_detections = [d for d in detections if (now - d['timestamp']) < 1.0]

            if len(recent_detections) < 2:
                return

            # IMPORTANT: Garder uniquement la MEILLEURE d√©tection par routeur (√©viter duplicates)
            # Grouper par node et garder le meilleur RSSI pour chaque routeur
            best_by_router = {}
            for d in recent_detections:
                node = d['node']
                if node not in best_by_router or d['rssi'] > best_by_router[node]['rssi']:
                    best_by_router[node] = d

            # Convertir en liste et v√©rifier qu'on a au moins 2 routeurs DIFF√âRENTS
            unique_detections = list(best_by_router.values())

            if len(unique_detections) < 2:
                return

            # Trier par RSSI (meilleurs signaux en premier) et garder top 5 routeurs
            unique_detections.sort(key=lambda d: d['rssi'], reverse=True)
            top_detections = unique_detections[:5]

            # Calculer position par barycentre pond√©r√©
            total_weight = 0
            weighted_x = 0
            weighted_y = 0
            rssi_values = {}
            nodes_with_position = []

            for detection in top_detections:
                node_name = detection['node']
                rssi = detection['rssi']
                rssi_values[node_name] = rssi

                # R√©cup√©rer position du node (chercher par nom OU par RLOC16)
                node_pos = self.node_positions.get(node_name)

                # Si pas trouv√© par nom, chercher le RLOC16 correspondant
                if not node_pos:
                    # Trouver le RLOC16 √† partir du nom via le mapping
                    rloc16 = self.name_to_rloc16.get(node_name)
                    if rloc16:
                        node_pos = self.node_positions.get(rloc16)

                if not node_pos:
                    continue

                nodes_with_position.append(node_name)

                # Pond√©ration: w = 10^(RSSI/20) (en dB logarithmique)
                # RSSI typique: -30 dBm (proche) √† -80 dBm (loin)
                weight = 10 ** (rssi / 20.0)

                weighted_x += node_pos['x'] * weight
                weighted_y += node_pos['y'] * weight
                total_weight += weight

            if total_weight == 0:
                return

            # Position finale
            pos_x = weighted_x / total_weight
            pos_y = weighted_y / total_weight

            # Confidence bas√©e sur nombre de routeurs
            confidence = min(100, len(top_detections) * 25)  # 2‚Üí50%, 3‚Üí75%, 4+‚Üí100%

            # Stocker position
            self.badge_positions[badge_addr] = {
                'x': pos_x,
                'y': pos_y,
                'confidence': confidence,
                'timestamp': datetime.now()
            }

            # √âmettre via WebSocket
            socketio.emit('badge_position', {
                'badge_addr': badge_addr,
                'code': code,
                'x': pos_x,
                'y': pos_y,
                'confidence': confidence,
                'rssi_values': rssi_values,
                'nb_routers': len(top_detections),
                'timestamp': datetime.now().isoformat()
            })

            # Log concis: code, routeurs, position
            router_list = ', '.join(nodes_with_position)
            print(f"üìç {code}: ({pos_x:.0f},{pos_y:.0f}) {confidence}% [{router_list}]")

        except Exception as e:
            print(f"‚ùå Erreur triangulation {code}: {e}")

    def announce_server(self, flash_yellow=False):
        """Annonce l'adresse du serveur √† tous les nodes"""
        print("\nüì¢ Annonce du serveur aux nodes...")
        
        addresses = self.registry.get_all_addresses()
        if not addresses:
            print("‚ö†Ô∏è Aucun node configur√© dans adresses.json")
            return
        
        # Si demand√©, allumer les LEDs rouges (anciennement jaunes)
        if flash_yellow:
            print("üíõ Allumage des LEDs rouges...")
            for addr in addresses:
                self.send_coap_post(addr, "led", "red:on")
        
        # Envoyer server-id √† chaque node
        success_count = 0
        for name, node_data in self.registry.nodes.items():
            # G√©rer le nouveau format avec dictionnaire
            if isinstance(node_data, dict):
                addr = node_data.get('address')
            else:
                # Ancien format (compatibilit√©)
                addr = node_data
            
            if addr and self.send_coap_post(addr, "server-id", "server-id"):
                print(f"  ‚úì Annonce envoy√©e √† {name}")
                success_count += 1
            else:
                print(f"  ‚ùå √âchec annonce √† {name}")
        
        print(f"üì° Annonce termin√©e: {success_count}/{len(addresses)} nodes contact√©s")
        
        # Si on a allum√© les LEDs rouges, les √©teindre apr√®s 1 seconde
        if flash_yellow:
            def turn_off_red():
                time.sleep(1)
                for addr in addresses:
                    self.send_coap_post(addr, "led", "red:off")
                print("üíõ LEDs rouges √©teintes")
            
            threading.Thread(target=turn_off_red).start()
    
    def delayed_announce(self):
        """Annonce le serveur apr√®s un d√©lai"""
        time.sleep(2)  # Attendre que le serveur soit bien d√©marr√©
        print("\nüîÑ Annonce automatique du serveur...")
        self.announce_server()
    
    def demo_loop(self):
        """Boucle de d√©monstration"""
        print("\nüé≠ MODE D√âMO ACTIV√â")
        print("   - Flash LED rouge : 500ms ON / 500ms OFF")
        print("   - Annonce serveur : toutes les 30s")
        print("   - Tapez 'stop' ou Ctrl+C pour arr√™ter\n")
        
        last_announce = time.time()
        announce_interval = 30  # secondes
        
        flash_count = 0
        while self.demo_mode and self.running:
            try:
                current_time = time.time()
                
                # V√©rifier si on doit faire une annonce (toutes les 30 secondes)
                if current_time - last_announce >= announce_interval:
                    print(f"\r[{datetime.now().strftime('%H:%M:%S')}] üì¢ Annonce serveur...                    ")
                    # Annonce silencieuse
                    addresses = self.registry.get_all_addresses()
                    if addresses:
                        # Cr√©er un socket temporaire pour l'envoi
                        sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
                        try:
                            # Flash jaune
                            for addr in addresses:
                                sock.sendto(self.create_coap_post_packet("led", "yellow:on"), (addr, COAP_PORT))
                            # Envoyer server-id
                            for name, addr in self.registry.nodes.items():
                                packet = self.create_coap_post_packet("server-id", "server-id")
                                sock.sendto(packet, (addr, COAP_PORT))
                            time.sleep(1)
                            # √âteindre jaune
                            for addr in addresses:
                                sock.sendto(self.create_coap_post_packet("led", "yellow:off"), (addr, COAP_PORT))
                        finally:
                            sock.close()
                    last_announce = current_time
                
                # Flash continu des LEDs rouges - SILENCIEUX
                addresses = self.registry.get_all_addresses()
                if addresses:
                    # Cr√©er un socket temporaire pour l'envoi
                    sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
                    try:
                        # Allumer
                        for addr in addresses:
                            sock.sendto(self.create_coap_post_packet("led", "red:on"), (addr, COAP_PORT))
                        time.sleep(0.5)
                        # √âteindre
                        for addr in addresses:
                            sock.sendto(self.create_coap_post_packet("led", "red:off"), (addr, COAP_PORT))
                        time.sleep(0.5)
                    finally:
                        sock.close()
                
                # Afficher un indicateur tournant pour montrer que le d√©mo est actif
                flash_count += 1
                spinner = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
                print(f"\r{spinner[flash_count % len(spinner)]} Mode d√©mo actif... (stop ou Ctrl+C pour arr√™ter)", end='', flush=True)
                    
            except Exception as e:
                print(f"\r‚ùå Erreur dans le mode d√©mo: {e}")
                self.demo_mode = False
        
        print("\rüé≠ Mode d√©mo d√©sactiv√©                                          ")
    
    def handle_location_change(self, loc_code: str):
        """Handler pour les changements de localisation - g√®re le mode suivi de position"""
        try:
            # Chercher si le loc_code correspond √† un node connu
            node_name = None
            
            # Essayer de mapper le loc_code vers un nom de node
            # Par exemple: "s1Z" -> node "s1Z" ou chercher dans les adresses
            for name, node_data in self.registry.nodes.items():
                # V√©rifier si le nom du node correspond au loc_code
                if name.lower() == loc_code.lower():
                    node_name = name
                    break
                # Ou si le loc_code est dans le nom
                elif loc_code.lower() in name.lower():
                    node_name = name
                    break
            
            # V√©rifier si le node est connu et a une adresse
            node_address = None
            if node_name and node_name in self.registry.nodes:
                node_data = self.registry.nodes[node_name]
                if isinstance(node_data, dict):
                    node_address = node_data.get('address')
                else:
                    node_address = node_data
            
            # Si c'est un node connu avec une adresse
            if node_name and node_address:
                # Si le mode suivi est actif
                if self.tracking_mode:
                    print(f"\nüéØ Mode Suivi: Changement vers node {node_name}")
                    
                    # Si c'est une nouvelle node
                    if self.current_tracking_node != node_name:
                        self.current_tracking_node = node_name
                        
                        # Obtenir les nodes connexes
                        connected_nodes = self.registry.get_connected_nodes(node_name)
                        all_nodes = self.registry.get_all_node_names()
                        
                        print(f"   Nodes connexes de {node_name}: {connected_nodes}")
                        
                        # Flash LED rouge de la node active (200ms)
                        def flash_red():
                            self.send_coap_post(node_address, "led", "red:on")
                            time.sleep(0.2)
                            self.send_coap_post(node_address, "led", "red:off")
                        
                        # Lancer le flash dans un thread pour ne pas bloquer
                        flash_thread = threading.Thread(target=flash_red)
                        flash_thread.daemon = True
                        flash_thread.start()
                        
                        # Pour chaque node, allumer ou √©teindre selon si elle est connexe
                        for node in all_nodes:
                            if node == node_name:
                                continue  # Skip la node active
                            
                            node_data = self.registry.nodes.get(node, {})
                            if isinstance(node_data, dict):
                                addr = node_data.get('address')
                                if addr:
                                    if node in connected_nodes:
                                        # Allumer les nodes connexes
                                        print(f"   üí° Allumer node connexe: {node}")
                                        self.send_coap_post(addr, "led", "light:on")
                                        if addr not in self.led_states:
                                            self.led_states[addr] = {}
                                        self.led_states[addr]['light'] = True
                                    else:
                                        # √âteindre les nodes non-connexes
                                        print(f"   üîå √âteindre node non-connexe: {node}")
                                        self.send_coap_post(addr, "led", "light:off")
                                        if addr not in self.led_states:
                                            self.led_states[addr] = {}
                                        self.led_states[addr]['light'] = False
                        
                        # √âmettre un √©v√©nement pour l'interface web
                        tracking_event = {
                            'type': 'tracking_update',
                            'active_node': node_name,
                            'connected_nodes': connected_nodes,
                            'timestamp': datetime.now().isoformat()
                        }
                        socketio.emit('tracking_update', tracking_event)
                else:
                    # Mode normal : faire un flash de la LED rouge
                    print(f"üî¥ Envoi flash LED rouge au node {node_name} ({node_address})")
                    try:
                        # Allumer la LED rouge
                        self.send_coap_post(node_address, "led", "red:on")
                        
                        # Attendre 200ms
                        time.sleep(0.2)
                        
                        # √âteindre la LED rouge
                        self.send_coap_post(node_address, "led", "red:off")
                        
                        print(f"   ‚úÖ Flash LED rouge termin√©")
                    except Exception as e:
                        print(f"   ‚ùå Erreur envoi commande: {e}")
            else:
                print(f"‚ö†Ô∏è Node inconnu ou sans adresse pour loc_code: {loc_code} (ignor√©)")
                
        except Exception as e:
            print(f"‚ùå Erreur dans handle_location_change: {e}")
    
    def handle_tb_telemetry_update(self, node_name: str, telemetry: dict):
        """Handler pour les mises √† jour de t√©l√©m√©trie re√ßues depuis ThingsBoard WebSocket"""
        try:
            # D√©sactiv√© pour r√©duire le bruit - ce sont les updates re√ßues DE ThingsBoard
            # print(f"üîÑ Mise √† jour ThingsBoard pour {node_name}: {telemetry}")
            
            # G√©rer les mises √† jour loc_code
            if 'loc_code' in telemetry:
                # √âmettre via Socket.IO pour l'interface web
                socketio.emit('loc_code_update', {
                    'device': node_name,
                    'loc_code': telemetry['loc_code'],
                    'timestamp': datetime.now().isoformat()
                })
            
            # Mettre √† jour l'√©tat batterie si pr√©sent
            if 'battery_level' in telemetry or 'battery_value' in telemetry:
                battery_info = self.battery_status.get(node_name, {})
                
                if 'battery_level' in telemetry:
                    battery_info['percentage'] = telemetry['battery_level']
                if 'battery_value' in telemetry:
                    battery_info['voltage'] = telemetry['battery_value']
                    
                battery_info['timestamp'] = datetime.now()
                self.battery_status[node_name] = battery_info
                
                # √âmettre via Socket.IO pour l'interface web
                socketio.emit('battery_update', {
                    'node': node_name,
                    'voltage': battery_info.get('voltage', 0),
                    'percentage': battery_info.get('percentage', 0),
                    'timestamp': battery_info['timestamp'].isoformat()
                })
            
            # Mettre √† jour l'√©tat des LEDs si pr√©sent
            if 'led_state' in telemetry:
                led_states = telemetry['led_state']
                if node_name in self.registry.nodes:
                    node_data = self.registry.nodes[node_name]
                    addr = node_data.get('address') if isinstance(node_data, dict) else node_data
                    
                    if addr not in self.led_states:
                        self.led_states[addr] = {}
                    
                    # Parser l'√©tat des LEDs (format attendu: {"red": true/false, "light": true/false})
                    if isinstance(led_states, dict):
                        for led, state in led_states.items():
                            self.led_states[addr][led] = state
                            
                            # √âmettre via Socket.IO
                            socketio.emit('led_update', {
                                'node': node_name,
                                'led': led,
                                'state': state
                            })
            
            # Traiter les √©v√©nements bouton
            if 'button_state' in telemetry:
                button_state = telemetry['button_state']
                
                # Cr√©er un √©v√©nement bouton
                event = {
                    'node': node_name,
                    'timestamp': datetime.now().isoformat(),
                    'type': 'button',
                    'state': button_state
                }
                
                self.button_events.append(event)
                self.event_count += 1
                
                # √âmettre via Socket.IO
                socketio.emit('button_event', event)
            
            # Autres donn√©es de t√©l√©m√©trie (temp√©rature, humidit√©, etc.)
            if 'temperature' in telemetry or 'humidity' in telemetry:
                socketio.emit('telemetry_update', {
                    'node': node_name,
                    'data': telemetry,
                    'timestamp': datetime.now().isoformat()
                })
                
        except Exception as e:
            print(f"‚ùå Erreur traitement t√©l√©m√©trie ThingsBoard: {e}")
    
    def run(self):
        """Lance le serveur"""
        print("üåê Serveur CoAP de contr√¥le")
        print(f"   Port: {COAP_PORT}")
        print("=" * 50)
        
        # Connexion √† ThingsBoard si configur√©
        if TB_CONFIG['username'] and TB_CONFIG['password']:
            self.thingsboard.connect()
        else:
            print("‚ÑπÔ∏è ThingsBoard non configur√© (d√©finir TB_USERNAME et TB_PASSWORD)")
        
        # Socket UDP IPv6
        self.sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        try:
            self.sock.bind(('::', COAP_PORT))
            print("‚úì Serveur d√©marr√© sur toutes les interfaces IPv6")
        except:
            # Fallback sur IPv4
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sock.bind(('', COAP_PORT))
            print("‚úì Serveur d√©marr√© en IPv4")
        
        print("\nüìç Ressources disponibles:")
        print("   - /button : re√ßoit les √©v√©nements button-pressed")
        print("   - /server-id : enregistrement des nodes")
        print("   - /battery : re√ßoit les rapports de batterie")
        print("   - /ble-beacon : re√ßoit les d√©tections BLE beacon")
        
        self.running = True
        
        # Thread pour les commandes interactives
        cmd_thread = threading.Thread(target=self.command_loop)
        cmd_thread.daemon = True
        cmd_thread.start()
        
        # Annoncer le serveur aux nodes apr√®s un court d√©lai
        announce_thread = threading.Thread(target=self.delayed_announce)
        announce_thread.daemon = True
        announce_thread.start()
        
        print("\n‚è≥ En attente de messages...\n")
        
        try:
            while self.running:
                # Recevoir un paquet
                data, addr = self.sock.recvfrom(4096)
                
                # Parser le paquet CoAP
                packet = self.parse_coap_packet(data)
                
                if packet:
                    self.event_count += 1
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Afficher message CoAP sauf pour ble-beacon (d√©j√† logu√© dans handle_ble_beacon)
                    if packet['uri_path'] != 'ble-beacon':
                        print(f"\nüì® [{timestamp}] Message CoAP #{self.event_count}")
                        print(f"   Source: {addr[0]}")
                        print(f"   URI: /{packet['uri_path']}")
                        print(f"   Code: {packet['code']}")

                    # Mettre √† jour le statut du node
                    if addr[0] not in self.node_status:
                        self.node_status[addr[0]] = {}
                    self.node_status[addr[0]]['last_seen'] = datetime.now()

                    # Traiter selon l'URI
                    if packet['uri_path'] == 'battery':
                        # Traiter le rapport batterie
                        message = ""
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                            print(f"   Payload: '{message}'")
                        else:
                            print(f"   Payload: (vide)")
                        self.handle_battery_report(addr[0], message)
                    elif packet['uri_path'] == 'button':
                        # Traiter l'√©v√©nement button m√™me sans payload
                        message = ""
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                            print(f"   Payload: '{message}'")
                        else:
                            print(f"   Payload: (vide)")
                        self.handle_button_event(addr[0], message)
                    elif packet['uri_path'] == 'server-id':
                        message = ""
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                            print(f"   Payload: '{message}'")
                        self.handle_server_id(addr[0], message)
                    elif packet['uri_path'] == 'ble-beacon':
                        message = ""
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                        self.handle_ble_beacon(addr[0], message)
                    else:
                        # Pour les autres URIs, afficher le payload s'il existe
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                            print(f"   Payload: '{message}'")
                    
                    # Envoyer ACK si n√©cessaire
                    if packet['type'] == 0:  # CON (Confirmable)
                        response = self.create_coap_response(packet['message_id'])
                        self.sock.sendto(response, addr)
                        print("   ‚Üê ACK envoy√©")
                        
        except KeyboardInterrupt:
            print("\n\n‚úã Arr√™t du serveur")
        finally:
            self.running = False
            if self.sock:
                self.sock.close()
            if self.thingsboard.connected:
                self.thingsboard.disconnect()
            print(f"üìä Total √©v√©nements: {self.event_count}")
    
    def show_help(self):
        """Affiche l'aide des commandes"""
        print("\nüéÆ Commandes disponibles:")
        print("  help     - Afficher cette aide")
        print("  list     - Lister tous les nodes")
        print("  reload   - Recharger adresses.json")
        print("  announce - Annoncer le serveur aux nodes")
        print("  flash    - Faire clignoter tous les nodes (1 fois)")
        print("  path [vitesse_ms] - Chemin lumineux (d√©faut: 1000ms)")
        print("    Exemple: path 500 pour 500ms par node")
        print("  blink <node|all> <led> [p√©riode_ms] [duty_%] - Faire clignoter une LED")
        print("    LEDs: red, light, all")
        print("    Exemples: blink d2C red          (1000ms, 50%)")
        print("              blink all red 500 25   (500ms, 25%)")
        print("              blink d3D light 2000 75 (2000ms, 75%)")
        print("  blink stop [node|all] - Arr√™ter le clignotement")
        print("  led <node> <cmd> - Envoyer commande LED (contr√¥le direct)")
        print("    Commandes: red:on/off, light:on/off, all:on/off")
        print("  light on/off - Allumer/√©teindre toutes les LED externes")
        print("  battery  - Afficher l'√©tat des batteries")
        print("  beacon   - Afficher les beacons BLE d√©tect√©s")
        print("  quality  - Statistiques de qualit√© des badges (s√©quence po1-po0)")
        print("  tb       - √âtat de la connexion ThingsBoard")
        print("  tb refresh - Rafra√Æchir le cache des assets ThingsBoard")
        print("  tb reconnect - Forcer la reconnexion √† ThingsBoard")
        print("  tb devices - Afficher les devices et leurs positions loc_code")
        print("  demo     - Mode d√©mo (announce + flash toutes les 10s)")
        print("  stop     - Arr√™ter le mode d√©mo")
        print("  quit     - Quitter")
        print()
    
    def command_loop(self):
        """Boucle de commandes interactives"""
        time.sleep(1)  # Attendre que le serveur d√©marre
        
        self.show_help()
        
        while self.running:
            try:
                cmd = input("coap> ").strip()
                
                if cmd == "quit":
                    self.running = False
                    self.demo_mode = False
                    break
                elif cmd == "help":
                    self.show_help()
                elif cmd == "list":
                    print("\nüìã Nodes enregistr√©s:")
                    for name, node_data in self.registry.nodes.items():
                        if isinstance(node_data, dict):
                            addr = node_data.get('address', '')
                            ordre = node_data.get('ordre', 0)
                            ordre_str = f" (ordre: {ordre})" if ordre > 0 else " (pas dans le chemin)"
                            print(f"  {name}: {addr}{ordre_str}")
                        else:
                            # Ancien format
                            print(f"  {name}: {node_data}")
                    print()
                elif cmd == "reload":
                    self.registry.load()
                elif cmd == "announce":
                    self.announce_server()
                elif cmd == "battery":
                    # Afficher l'√©tat des batteries
                    print("\nüîã √âtat des batteries:")
                    if not self.battery_status:
                        print("   Aucun rapport de batterie re√ßu")
                    else:
                        for node_name, data in self.battery_status.items():
                            if data['current']:
                                current = data['current']
                                age = (datetime.now() - current['timestamp']).total_seconds()
                                status_icon = "üîã" if current['percentage'] > 20 else "ü™´"
                                print(f"   {status_icon} {node_name}: {current['voltage']:.2f}V ({current['percentage']}%) - il y a {int(age)}s")
                                
                                # Afficher l'historique r√©cent si demand√©
                                if len(data['history']) > 1:
                                    voltages = [h['voltage'] for h in data['history']]
                                    avg_voltage = sum(voltages) / len(voltages)
                                    trend = "üìà" if voltages[-1] > voltages[0] else "üìâ" if voltages[-1] < voltages[0] else "‚û°Ô∏è"
                                    print(f"      Moyenne: {avg_voltage:.2f}V {trend}")
                    print()
                elif cmd == "beacon":
                    # Afficher les d√©tections BLE beacon
                    print("\nüì° D√©tections BLE Beacon:")
                    if not self.ble_detections:
                        print("   Aucun beacon d√©tect√©")
                    else:
                        for code, data in self.ble_detections.items():
                            age = (datetime.now() - data['timestamp']).total_seconds()
                            print(f"   {code}: {data['addr']} (RSSI: {data['rssi']} dBm)")
                            print(f"      Node: {data['node']} - Il y a {int(age)}s")
                    print()

                elif cmd == "quality":
                    # Afficher les statistiques de qualit√© des badges
                    print("\nüìä Badge Quality Report\n")
                    if not self.badge_trackers:
                        print("   Aucun badge track√©")
                    else:
                        for addr, tracker in self.badge_trackers.items():
                            stats = tracker.get_stats()
                            print(f"Badge {addr[-8:]}:")
                            print(f"  Runtime         : {int(stats['runtime_sec'])}s")
                            print(f"  Frames expected : {stats['total_expected']}")
                            print(f"  Frames received : {stats['received']}")
                            print(f"  Frames missed   : {stats['missed']}")
                            print(f"  Success rate    : {stats['success_rate']:.1f}%")
                            print(f"  Last code       : {stats['last_code']}")
                            print()

                elif cmd == "flash":
                    # Faire clignoter toutes les LEDs externes
                    print("üí° Flash toutes les LED externes...")
                    addresses = self.registry.get_all_addresses()
                    for addr in addresses:
                        self.send_coap_post(addr, "led", "light:on")
                    time.sleep(1)
                    for addr in addresses:
                        self.send_coap_post(addr, "led", "light:off")
                elif cmd.startswith("path") or cmd.startswith("chemin"):
                    # Chemin lumineux avec vitesse param√©trable
                    parts = cmd.split()
                    speed_ms = 1000  # Vitesse par d√©faut
                    
                    # Parser la vitesse si fournie
                    if len(parts) >= 2:
                        try:
                            speed_ms = int(parts[1])
                            if speed_ms < 100:
                                speed_ms = 100  # Minimum 100ms
                            elif speed_ms > 10000:
                                speed_ms = 10000  # Maximum 10s
                        except ValueError:
                            print("‚ö†Ô∏è Vitesse invalide, utilisation de 1000ms par d√©faut")
                    
                    print(f"üåà Chemin lumineux d√©marr√© (vitesse: {speed_ms}ms)")
                    print("   Appuyez sur Ctrl+C pour arr√™ter...")
                    
                    # R√©cup√©rer les nodes tri√©s par ordre
                    sorted_nodes = self.registry.get_nodes_sorted_by_order()
                    
                    if not sorted_nodes:
                        print("‚ùå Aucun node avec un ordre d√©fini (ordre > 0)")
                    else:
                        print(f"   Nodes dans l'ordre: {[n['name'] for n in sorted_nodes]}")
                        
                        try:
                            while True:
                                for node in sorted_nodes:
                                    # Allumer le node actuel
                                    self.send_coap_post(node['address'], "led", "light:on")
                                    time.sleep(speed_ms / 1000.0)
                                    # √âteindre le node actuel
                                    self.send_coap_post(node['address'], "led", "light:off")
                                    time.sleep(50 / 1000.0)  # Petite pause entre nodes
                        except KeyboardInterrupt:
                            print("\n‚èπÔ∏è Chemin lumineux arr√™t√©")
                            # √âteindre toutes les LEDs
                            for node in sorted_nodes:
                                self.send_coap_post(node['address'], "led", "light:off")
                elif cmd.startswith("blink"):
                    # Commande blink avec param√®tres optionnels
                    parts = cmd.split()
                    
                    # V√©rifier si c'est une commande stop
                    if len(parts) >= 2 and parts[1] == "stop":
                        # blink stop [node|all]
                        target = parts[2] if len(parts) >= 3 else "all"
                        
                        if target == "all":
                            print("‚èπÔ∏è Arr√™t du clignotement sur tous les nodes...")
                            addresses = self.registry.get_all_addresses()
                            for addr in addresses:
                                self.send_coap_post(addr, "blink", "stop")
                        else:
                            # Arr√™ter sur un node sp√©cifique
                            if target in self.registry.nodes:
                                node_data = self.registry.nodes[target]
                                if isinstance(node_data, dict):
                                    addr = node_data.get('address')
                                else:
                                    addr = node_data
                                
                                if addr:
                                    print(f"‚èπÔ∏è Arr√™t du clignotement sur {target}...")
                                    self.send_coap_post(addr, "blink", "stop")
                                else:
                                    print(f"‚ùå Adresse manquante pour '{target}'")
                            else:
                                print(f"‚ùå Node '{target}' non trouv√©")
                    else:
                        # Commande blink normale
                        if len(parts) < 3:
                            print("‚ùå Usage: blink <node|all> <led> [p√©riode_ms] [duty_%]")
                            print("         blink stop [node|all]")
                        else:
                            target = parts[1]  # node ou "all"
                            led_type = parts[2]  # red, light, all
                            period_ms = parts[3] if len(parts) >= 4 else "1000"
                            duty_cycle = parts[4] if len(parts) >= 5 else "50"
                            
                            # Construire le payload pour la ressource /blink
                            payload = f"{led_type}:{period_ms}:{duty_cycle}"
                            
                            if target == "all":
                                print(f"üí´ Clignotement {led_type} sur tous les nodes ({period_ms}ms, {duty_cycle}%)...")
                                addresses = self.registry.get_all_addresses()
                                for addr in addresses:
                                    self.send_coap_post(addr, "blink", payload)
                            else:
                                # Envoyer √† un node sp√©cifique
                                if target in self.registry.nodes:
                                    node_data = self.registry.nodes[target]
                                    if isinstance(node_data, dict):
                                        addr = node_data.get('address')
                                    else:
                                        addr = node_data
                                    
                                    if addr:
                                        print(f"üí´ Clignotement {led_type} sur {target} ({period_ms}ms, {duty_cycle}%)...")
                                        self.send_coap_post(addr, "blink", payload)
                                    else:
                                        print(f"‚ùå Adresse manquante pour '{target}'")
                                else:
                                    print(f"‚ùå Node '{target}' non trouv√©")
                elif cmd == "demo":
                    if not self.demo_mode:
                        self.demo_mode = True
                        # Lancer le thread de d√©mo
                        demo_thread = threading.Thread(target=self.demo_loop)
                        demo_thread.daemon = True
                        demo_thread.start()
                    else:
                        print("‚ö†Ô∏è Mode d√©mo d√©j√† actif. Utilisez 'stop' ou Ctrl+C pour l'arr√™ter.")
                elif cmd == "stop":
                    if self.demo_mode:
                        print("‚èπÔ∏è Arr√™t du mode d√©mo...")
                        self.demo_mode = False
                        time.sleep(1)  # Laisser le temps au thread de s'arr√™ter
                    else:
                        print("‚ÑπÔ∏è Le mode d√©mo n'est pas actif")
                elif cmd == "tb":
                    # √âtat ThingsBoard
                    if self.thingsboard.connected:
                        print(f"‚úÖ ThingsBoard: Connect√© √† {TB_CONFIG['url']}")
                        print(f"   User: {TB_CONFIG['username']}")
                        
                        # Afficher l'√¢ge du token
                        token_age = int(time.time() - self.thingsboard.token_timestamp)
                        token_remaining = max(0, self.thingsboard.token_lifetime - token_age)
                        print(f"   Token: valide encore {token_remaining}s ({token_age}s d'√¢ge)")
                        
                        print(f"   Assets en cache: {len(self.thingsboard.asset_cache)}")
                        if self.thingsboard.asset_cache:
                            print("   Assets:")
                            for name in sorted(self.thingsboard.asset_cache.keys()):
                                print(f"     - {name}")
                        
                        print(f"\n   Devices en cache: {len(self.thingsboard.device_cache)}")
                        if self.thingsboard.device_cache:
                            print("   Devices avec loc_code:")
                            for name in sorted(self.thingsboard.device_cache.keys()):
                                loc_info = self.thingsboard.device_loc_code.get(name, {})
                                loc_value = loc_info.get('value', 'N/A')
                                if loc_value and loc_value != 'N/A':
                                    ts = loc_info.get('timestamp')
                                    if ts:
                                        age = int((time.time() * 1000 - ts) / 1000)
                                        print(f"     üìç {name}: {loc_value} (il y a {age}s)")
                                    else:
                                        print(f"     üìç {name}: {loc_value}")
                                else:
                                    print(f"     ‚óã {name}: (pas de position)")
                    else:
                        print("‚ùå ThingsBoard: Non connect√©")
                elif cmd == "tb refresh":
                    # Rafra√Æchir le cache des assets
                    if self.thingsboard.connected:
                        self.thingsboard.refresh_asset_cache()
                    else:
                        print("‚ùå ThingsBoard non connect√©")
                elif cmd == "tb devices":
                    # Afficher l'√©tat des devices
                    if self.thingsboard.connected:
                        print("\nüì± Devices ThingsBoard:")
                        if not self.thingsboard.device_cache:
                            print("   Aucun device trouv√©")
                        else:
                            print(f"   Total: {len(self.thingsboard.device_cache)} devices")
                            print("\n   üìç Positions LOC_CODE:")
                            print("   " + "="*50)
                            
                            # Trier par nom
                            for name in sorted(self.thingsboard.device_cache.keys()):
                                loc_info = self.thingsboard.device_loc_code.get(name, {})
                                loc_value = loc_info.get('value')
                                
                                if loc_value:
                                    ts = loc_info.get('timestamp')
                                    if ts:
                                        age = int((time.time() * 1000 - ts) / 1000)
                                        if age < 60:
                                            age_str = f"{age}s"
                                        elif age < 3600:
                                            age_str = f"{age//60}min"
                                        else:
                                            age_str = f"{age//3600}h"
                                        
                                        # Ic√¥ne selon l'√¢ge
                                        if age < 10:
                                            icon = "üü¢"  # Tr√®s r√©cent
                                        elif age < 60:
                                            icon = "üü°"  # R√©cent
                                        else:
                                            icon = "üî¥"  # Ancien
                                        
                                        print(f"   {icon} {name:20} : {loc_value:15} (il y a {age_str})")
                                    else:
                                        print(f"   üîµ {name:20} : {loc_value:15}")
                                else:
                                    print(f"   ‚ö™ {name:20} : {'Pas de position':15}")
                            
                            # Statistiques
                            with_position = sum(1 for loc in self.thingsboard.device_loc_code.values() if loc.get('value'))
                            print("\n   üìä Statistiques:")
                            print(f"      ‚Ä¢ Devices avec position: {with_position}/{len(self.thingsboard.device_cache)}")
                            
                            # Afficher les devices DALKIA sp√©cifiquement
                            dalkia_devices = [name for name in self.thingsboard.device_cache.keys() if 'DALKIA' in name.upper()]
                            if dalkia_devices:
                                print(f"\n   üè∑Ô∏è Badges DALKIA d√©tect√©s: {len(dalkia_devices)}")
                                for name in sorted(dalkia_devices):
                                    loc_info = self.thingsboard.device_loc_code.get(name, {})
                                    loc_value = loc_info.get('value', 'N/A')
                                    print(f"      ‚Ä¢ {name}: {loc_value}")
                    else:
                        print("‚ùå ThingsBoard non connect√©")
                elif cmd == "tb reconnect":
                    # Forcer la reconnexion
                    print("üîÑ Reconnexion √† ThingsBoard...")
                    if self.thingsboard.reconnect():
                        print("‚úÖ Reconnexion r√©ussie")
                    else:
                        print("‚ùå √âchec de la reconnexion")
                elif cmd.startswith("light "):
                    # Commande light pour tous les nodes
                    parts = cmd.split()
                    if len(parts) >= 2:
                        action = parts[1]
                        if action in ["on", "off"]:
                            print(f"üí° Envoi commande light:{action} √† tous les nodes...")
                            addresses = self.registry.get_all_addresses()
                            for addr in addresses:
                                self.send_coap_post(addr, "led", f"light:{action}")
                        else:
                            print("‚ùå Usage: light on/off")
                elif cmd.startswith("led "):
                    parts = cmd.split()
                    if len(parts) >= 3:
                        node_name = parts[1]
                        led_cmd = parts[2]
                        if node_name in self.registry.nodes:
                            node_data = self.registry.nodes[node_name]
                            # G√©rer le nouveau format avec dictionnaire
                            if isinstance(node_data, dict):
                                addr = node_data.get('address')
                            else:
                                # Ancien format (compatibilit√©)
                                addr = node_data
                            
                            if addr:
                                self.send_coap_post(addr, "led", led_cmd)
                            else:
                                print(f"‚ùå Adresse manquante pour '{node_name}'")
                        else:
                            print(f"‚ùå Node '{node_name}' non trouv√©")
                else:
                    if cmd:
                        print("‚ùå Commande inconnue")
                        
            except EOFError:
                break
            except KeyboardInterrupt:
                if self.demo_mode:
                    print("\n\n‚èπÔ∏è Arr√™t du mode d√©mo...")
                    self.demo_mode = False
                    time.sleep(1)  # Laisser le temps au thread de s'arr√™ter
                    print()  # Nouvelle ligne pour le prompt
                else:
                    print("\n")
                    break
            except Exception as e:
                print(f"Erreur: {e}")

# Instances globales pour les routes Flask
coap_server = None

# Module-level dict that persists across reimports (by Flask workers)
# This solves the "coap_server is None" issue when workers reimport the module
_server_instances = {}

def get_coap_server():
    """Retourne l'instance du serveur CoAP avec lazy initialization

    Cr√©e l'instance au premier appel, puis la r√©utilise.
    Cela r√©sout le probl√®me de module import√© plusieurs fois par les workers Flask.
    """
    if 'coap_server' not in _server_instances:
        # Lazy initialization: cr√©er l'instance seulement si elle n'existe pas encore
        print("üîß [get_coap_server] Lazy initialization - cr√©ation de CoAPServer")
        _server_instances['coap_server'] = CoAPServer()
        print(f"‚úÖ [get_coap_server] CoAPServer cr√©√©: {_server_instances['coap_server']} (id={id(_server_instances['coap_server'])})")

    return _server_instances.get('coap_server')
network_scanner = None
network_topology_data = None
topology_lock = threading.Lock()

# Border Router Manager (instance globale)
border_router_manager = BorderRouterManager(heartbeat_timeout=BR_HEARTBEAT_TIMEOUT)

# Native WebSocket Handler for Border Routers
from lib.native_websocket_handler import NativeWebSocketHandler
native_ws_handler = NativeWebSocketHandler(
    border_router_manager=border_router_manager,
    br_auth_enabled=BR_AUTH_ENABLED
)

# Fonction pour rafra√Æchir la topologie en arri√®re-plan
def refresh_topology_background():
    """Rafra√Æchit la topologie du r√©seau en arri√®re-plan"""
    global network_topology_data

    try:
        # Cr√©er une nouvelle boucle d'√©v√©nements pour ce thread
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        # Charger les noms depuis adresses.json
        address_names = {}
        try:
            with open(ADDRESSES_FILE, 'r') as f:
                data = json.load(f)
                nodes = data.get('nodes', {})
                for node_name, node_data in nodes.items():
                    if isinstance(node_data, dict):
                        addr = node_data.get('address')
                        if addr:
                            address_names[addr] = node_name
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur chargement noms depuis adresses.json: {e}")

        # Cr√©er le scanner avec les adresses connues et le mapping des noms
        known_addresses = coap_server.registry.get_all_addresses() if coap_server else []
        scanner = OpenThreadScanner(known_addresses=known_addresses, address_names=address_names)

        # Scanner le r√©seau
        loop.run_until_complete(scanner.build_topology())

        # Calculer les distances en sauts depuis le leader
        scanner.topology.calculate_hop_distances()

        # Convertir en JSON
        with topology_lock:
            network_topology_data = json.loads(scanner.topology.to_json())

        # Mettre √† jour le mapping nom ‚Üí RLOC16 pour la triangulation
        if coap_server:
            coap_server.name_to_rloc16.clear()
            for node in scanner.topology.nodes.values():
                if node.name and node.rloc16:
                    coap_server.name_to_rloc16[node.name] = node.rloc16
            print(f"üìç Mapping nom‚ÜíRLOC16 mis √† jour: {len(coap_server.name_to_rloc16)} entr√©es")

        # √âmettre via WebSocket
        socketio.emit('topology_update', network_topology_data)

        # Afficher les n≈ìuds d√©couverts avec leur nom
        node_count = len(scanner.topology.nodes)
        nodes_with_names = [n for n in scanner.topology.nodes.values() if n.name]
        print(f"‚úÖ Topologie rafra√Æchie: {node_count} n≈ìuds ({len(nodes_with_names)} nomm√©s)")
        for node in scanner.topology.nodes.values():
            node_label = f"{node.name} ({node.rloc16})" if node.name else node.rloc16
            print(f"   ‚Ä¢ {node_label} - {node.role}")

        loop.close()

    except Exception as e:
        print(f"‚ùå Erreur rafra√Æchissement topologie: {e}")
        import traceback
        traceback.print_exc()

# Routes Flask
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/beacons')
def beacons_page():
    """Page de suivi des beacons BLE d√©tect√©s"""
    return render_template('beacons.html')

@app.route('/ble_debug')
def ble_debug_page():
    """Page de debug BLE temps r√©el"""
    return render_template('ble_debug.html')

@app.route('/test_socket')
def test_socket_page():
    """Page de test Socket.IO basique"""
    return render_template('test_socket.html')

@app.route('/devices')
def devices_page():
    """Page de suivi des devices et leurs positions"""
    return render_template('devices.html')

@app.route('/network-map')
def network_map_page():
    """Page de cartographie du r√©seau OpenThread"""
    return render_template('network_map.html')

@app.route('/audio-control')
def audio_control_page():
    """Page de contr√¥le audio des nodes PTI (ancienne interface)"""
    return render_template('audio_control.html')

@app.route('/audio-library')
def audio_library_page():
    """Interface web pour la biblioth√®que audio"""
    return render_template('audio_library.html')

@app.route('/api/topology')
def get_topology():
    """Retourne la topologie actuelle du r√©seau"""
    with topology_lock:
        if network_topology_data:
            return jsonify(network_topology_data)
        else:
            # Si pas encore de donn√©es, retourner une structure vide
            return jsonify({
                'network_name': None,
                'partition_id': None,
                'last_update': None,
                'nodes': [],
                'statistics': {
                    'total_nodes': 0,
                    'leaders': 0,
                    'routers': 0,
                    'children': 0,
                    'max_depth': 0
                },
                'hierarchy': {}
            })

@app.route('/api/refresh_topology', methods=['POST'])
def refresh_topology():
    """Lance un scan du r√©seau et rafra√Æchit la topologie"""
    # Lancer dans un thread pour ne pas bloquer
    thread = threading.Thread(target=refresh_topology_background)
    thread.daemon = True
    thread.start()
    return jsonify({'status': 'started'})

@app.route('/api/br/status')
def get_br_status():
    """
    Retourne le statut de tous les Border Routers connect√©s

    Returns:
        JSON avec les statistiques et le statut de chaque BR
    """
    if not USE_WEBSOCKET_BR:
        return jsonify({
            'websocket_mode': False,
            'message': 'Border Router WebSocket mode is disabled'
        })

    try:
        # R√©cup√©rer les statistiques globales
        statistics = border_router_manager.get_statistics()

        # R√©cup√©rer le statut de tous les BRs
        border_routers = border_router_manager.get_all_brs_status()

        return jsonify({
            'websocket_mode': True,
            'statistics': statistics,
            'border_routers': border_routers,
            'timestamp': datetime.now().isoformat()
        })

    except Exception as e:
        logger.error(f"Erreur r√©cup√©ration statut BR: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/nodes')
def get_nodes():
    """Retourne la liste des nodes ACTIFS (dynamique) avec leurs √©tats"""
    # üÜï Obtenir les nodes actifs depuis le WebSocket handler (last_seen < 60s)
    active_nodes = native_ws_handler.get_active_nodes(timeout_seconds=60)

    print(f"üìã /api/nodes: {len(active_nodes)} active nodes found")

    nodes_data = []
    for node_info in active_nodes:
        name = node_info['name']
        ipv6 = node_info['ipv6']
        br_id = node_info['br_id']
        last_seen = node_info['last_seen']
        seconds_ago = node_info['seconds_ago']

        print(f"   - {name} @ {ipv6} (via {br_id}, seen {seconds_ago}s ago)")

        # R√©cup√©rer l'√©tat de la batterie
        battery = None
        if name in coap_server.battery_status and coap_server.battery_status[name]['current']:
            current = coap_server.battery_status[name]['current']
            battery = {
                'voltage': current['voltage'],
                'percentage': current['percentage'],
                'timestamp': current['timestamp'].isoformat()
            }

        # R√©cup√©rer l'√©tat des LEDs
        led_states = coap_server.led_states.get(ipv6, {})

        nodes_data.append({
            'name': name,
            'address': ipv6,
            'br_id': br_id,
            'last_seen': last_seen,
            'seconds_ago': seconds_ago,
            'ordre': 0,  # Ordre non applicable pour nodes dynamiques
            'battery': battery,
            'leds': {
                'red': led_states.get('red', False),
                'light': led_states.get('light', False)
            },
            'online': True  # Par d√©finition, si dans active_nodes, alors online
        })

    print(f"‚úÖ /api/nodes: Returning {len(nodes_data)} active nodes")
    return jsonify(nodes_data)

@app.route('/api/devices')
def get_devices():
    """Retourne la liste des devices ThingsBoard avec leurs positions loc_code"""
    devices_data = []
    
    if coap_server.thingsboard.connected:
        for device_name, device_id in coap_server.thingsboard.device_cache.items():
            loc_info = coap_server.thingsboard.device_loc_code.get(device_name, {})
            loc_value = loc_info.get('value')
            loc_timestamp = loc_info.get('timestamp')
            
            # Calculer l'√¢ge de la derni√®re position
            age_seconds = None
            if loc_timestamp:
                age_seconds = int((time.time() * 1000 - loc_timestamp) / 1000)
            
            devices_data.append({
                'name': device_name,
                'id': device_id,
                'loc_code': loc_value,
                'loc_timestamp': loc_timestamp,
                'age_seconds': age_seconds,
                'is_dalkia': 'DALKIA' in device_name.upper()
            })
    
    # Trier par nom
    devices_data.sort(key=lambda x: x['name'])
    
    return jsonify(devices_data)

@app.route('/api/command', methods=['POST'])
def send_command():
    """Envoie une commande √† un ou plusieurs nodes"""
    data = request.json
    command_type = data.get('type')
    target = data.get('target')  # 'all' ou nom du node
    
    if command_type == 'led':
        led = data.get('led')  # red, light, all
        action = data.get('action')  # on, off
        
        if target == 'all':
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "led", f"{led}:{action}")
                # Mettre √† jour l'√©tat local
                if addr not in coap_server.led_states:
                    coap_server.led_states[addr] = {}
                if led == 'all':
                    coap_server.led_states[addr]['red'] = (action == 'on')
                    coap_server.led_states[addr]['light'] = (action == 'on')
                else:
                    coap_server.led_states[addr][led] = (action == 'on')
        else:
            # Envoyer √† un node sp√©cifique
            if target in coap_server.registry.nodes:
                node_data = coap_server.registry.nodes[target]
                if isinstance(node_data, dict):
                    addr = node_data.get('address')
                else:
                    addr = node_data
                
                if addr:
                    coap_server.send_coap_post(addr, "led", f"{led}:{action}")
                    # Mettre √† jour l'√©tat local
                    if addr not in coap_server.led_states:
                        coap_server.led_states[addr] = {}
                    if led == 'all':
                        coap_server.led_states[addr]['red'] = (action == 'on')
                        coap_server.led_states[addr]['light'] = (action == 'on')
                    else:
                        coap_server.led_states[addr][led] = (action == 'on')
                    
                    # √âmettre la mise √† jour via WebSocket
                    socketio.emit('led_update', {
                        'node': target,
                        'led': led,
                        'state': action == 'on'
                    })
    
    elif command_type == 'tracking_mode':
        # Activer/d√©sactiver le mode suivi de position
        action = data.get('action')  # 'start' ou 'stop'
        
        if action == 'start':
            coap_server.tracking_mode = True
            coap_server.current_tracking_node = None
            print("üéØ Mode Suivi de Position ACTIV√â")
            
            # Allumer toutes les LEDs au d√©marrage
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "led", "light:on")
                if addr not in coap_server.led_states:
                    coap_server.led_states[addr] = {}
                coap_server.led_states[addr]['light'] = True
            
            # √âmettre l'√©v√©nement d'activation
            socketio.emit('tracking_mode_status', {
                'active': True,
                'timestamp': datetime.now().isoformat()
            })
            
        elif action == 'stop':
            coap_server.tracking_mode = False
            coap_server.current_tracking_node = None
            print("üõë Mode Suivi de Position D√âSACTIV√â")
            
            # √âteindre toutes les LEDs √† l'arr√™t
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "led", "light:off")
                coap_server.send_coap_post(addr, "blink_stop", "")
                if addr not in coap_server.led_states:
                    coap_server.led_states[addr] = {}
                coap_server.led_states[addr]['light'] = False
            
            # √âmettre l'√©v√©nement de d√©sactivation
            socketio.emit('tracking_mode_status', {
                'active': False,
                'timestamp': datetime.now().isoformat()
            })
    
    elif command_type == 'blink':
        led = data.get('led')
        period = data.get('period', 1000)
        duty = data.get('duty', 50)
        
        payload = f"{led}:{period}:{duty}"
        
        if target == 'all':
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "blink", payload)
        else:
            if target in coap_server.registry.nodes:
                node_data = coap_server.registry.nodes[target]
                if isinstance(node_data, dict):
                    addr = node_data.get('address')
                else:
                    addr = node_data
                if addr:
                    coap_server.send_coap_post(addr, "blink", payload)
    
    elif command_type == 'blink_stop':
        if target == 'all':
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "blink", "stop")
        else:
            if target in coap_server.registry.nodes:
                node_data = coap_server.registry.nodes[target]
                if isinstance(node_data, dict):
                    addr = node_data.get('address')
                else:
                    addr = node_data
                if addr:
                    coap_server.send_coap_post(addr, "blink", "stop")
    
    elif command_type == 'announce':
        coap_server.announce_server(flash_yellow=data.get('flash', False))
    
    elif command_type == 'demo':
        if not coap_server.demo_mode:
            coap_server.demo_mode = True
            demo_thread = threading.Thread(target=coap_server.demo_loop)
            demo_thread.daemon = True
            demo_thread.start()
            socketio.emit('demo_status', {'active': True})
    
    elif command_type == 'demo_stop':
        coap_server.demo_mode = False
        socketio.emit('demo_status', {'active': False})
    
    elif command_type == 'path':
        speed = data.get('speed', 1000)
        # Impl√©menter le chemin lumineux dans un thread
        def run_path():
            sorted_nodes = coap_server.registry.get_nodes_sorted_by_order()
            if sorted_nodes:
                for _ in range(3):  # 3 cycles
                    for node in sorted_nodes:
                        coap_server.send_coap_post(node['address'], "led", "light:on")
                        time.sleep(speed / 1000.0)
                        coap_server.send_coap_post(node['address'], "led", "light:off")
                        time.sleep(0.05)
        
        path_thread = threading.Thread(target=run_path)
        path_thread.daemon = True
        path_thread.start()
    
    return jsonify({'status': 'success'})

@app.route('/api/events')
def get_events():
    """Retourne l'historique des √©v√©nements boutons"""
    return jsonify(list(coap_server.button_events))

@app.route('/api/audio_command', methods=['POST'])
def send_audio_command():
    """Envoie une commande audio CoAP aux nodes (asynchrone pour ne pas bloquer SocketIO)"""
    data = request.json
    node_target = data.get('node')  # 'all' ou nom du node
    command = data.get('command')   # 'play:X' ou 'stop'

    if not command:
        return jsonify({'success': False, 'error': 'Missing command'}), 400

    # Fonction interne pour envoi asynchrone (ne bloque pas le thread Flask/SocketIO)
    def send_audio_async():
        try:
            if node_target == 'all':
                # Envoyer √† tous les nodes
                addresses = coap_server.registry.get_all_addresses()
                for addr in addresses:
                    coap_server.send_coap_post(addr, "audio", command)
            else:
                # Envoyer √† un node sp√©cifique
                if node_target in coap_server.registry.nodes:
                    node_data = coap_server.registry.nodes[node_target]
                    if isinstance(node_data, dict):
                        addr = node_data.get('address')
                    else:
                        addr = node_data

                    if addr:
                        coap_server.send_coap_post(addr, "audio", command)
                    else:
                        print(f"‚ö†Ô∏è Audio command: Node '{node_target}' address not found")
                else:
                    print(f"‚ö†Ô∏è Audio command: Node '{node_target}' not found")
        except Exception as e:
            print(f"‚ùå Erreur envoi audio async: {e}")

    # Lancer dans un thread s√©par√© pour ne pas bloquer Flask/SocketIO
    # Cela permet √† socketio.emit('ble_frame') de fonctionner en temps r√©el
    audio_thread = threading.Thread(target=send_audio_async)
    audio_thread.daemon = True
    audio_thread.start()

    # Retourner IMM√âDIATEMENT sans attendre l'envoi CoAP
    # Le thread Flask est lib√©r√© ‚Üí SocketIO peut diffuser les trames BLE en temps r√©el
    return jsonify({
        'success': True,
        'status': 'sent',
        'command': command,
        'target': node_target
    })

@app.route('/api/battery_history/<node_name>')
def get_battery_history(node_name):
    """Retourne l'historique de batterie d'un node"""
    if node_name in coap_server.battery_status:
        history = coap_server.battery_status[node_name]['history']
        data = [{
            'timestamp': h['timestamp'].isoformat(),
            'voltage': h['voltage'],
            'percentage': h['percentage']
        } for h in history]
        return jsonify(data)
    return jsonify([])

@app.route('/api/ble_history')
def get_ble_history():
    """Retourne l'historique complet des d√©tections BLE"""
    # Retourner les 200 derni√®res d√©tections, tri√©es par timestamp d√©croissant
    history = sorted(coap_server.ble_history, key=lambda x: x['timestamp'], reverse=True)[:200]
    return jsonify(history)

@app.route('/api/badge_positions')
def get_badge_positions():
    """Retourne les positions actuelles de tous les badges"""
    positions = []
    now = datetime.now()

    for badge_addr, pos_data in coap_server.badge_positions.items():
        # Calculer l'√¢ge de la position
        age_seconds = (now - pos_data['timestamp']).total_seconds()

        # Ne retourner que les positions r√©centes (< 10 secondes)
        if age_seconds < 10:
            # R√©cup√©rer le dernier code connu
            badge_detection = coap_server.ble_detections.get(badge_addr, {})
            code = badge_detection.get('code', 'unknown')

            positions.append({
                'badge_addr': badge_addr,
                'code': code,
                'x': pos_data['x'],
                'y': pos_data['y'],
                'confidence': pos_data['confidence'],
                'age_seconds': age_seconds,
                'timestamp': pos_data['timestamp'].isoformat()
            })

    return jsonify(positions)

@app.route('/api/node_positions', methods=['GET', 'POST'])
def handle_node_positions():
    """GET: Retourne les positions des nodes. POST: Met √† jour les positions"""
    if request.method == 'POST':
        # Client envoie les positions mises √† jour depuis localStorage
        positions_data = request.get_json()
        if positions_data:
            coap_server.node_positions = positions_data
            print(f"üìç Positions nodes mises √† jour: {len(positions_data)} nodes")
            return jsonify({'success': True, 'count': len(positions_data)})
        return jsonify({'success': False, 'error': 'No data provided'}), 400
    else:
        # Retourner les positions actuelles
        return jsonify(coap_server.node_positions)

# ========== AUDIO LIBRARY API ROUTES ==========

@app.route('/api/audio/catalog')
def get_audio_catalog():
    """Retourne le catalogue audio complet"""
    try:
        stats = audio_lib.get_statistics()
        categories = audio_lib.get_all_categories()

        return jsonify({
            'success': True,
            'statistics': stats,
            'categories': {
                name: {
                    'description': data.get('description'),
                    'count': data.get('count'),
                    'messages': audio_lib.format_for_web(data.get('messages', []))
                }
                for name, data in categories.items()
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/instant')
def get_instant_messages():
    """Retourne les 20 messages instantan√©s prioritaires pour le tertiaire"""
    try:
        instant = audio_lib.get_instant_messages(20)
        formatted = audio_lib.format_for_web(instant)

        return jsonify({
            'success': True,
            'count': len(formatted),
            'messages': formatted
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/category/<category>')
def get_audio_category(category):
    """Retourne tous les messages d'une cat√©gorie"""
    try:
        cat_data = audio_lib.get_category(category)

        if not cat_data:
            return jsonify({
                'success': False,
                'error': f'Category not found: {category}'
            }), 404

        messages = audio_lib.format_for_web(cat_data.get('messages', []))

        return jsonify({
            'success': True,
            'category': category,
            'description': cat_data.get('description'),
            'count': len(messages),
            'messages': messages
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/search')
def search_audio():
    """Recherche de messages audio par mots-cl√©s"""
    keywords = request.args.get('q', '')

    if not keywords:
        return jsonify({
            'success': False,
            'error': 'Missing search query parameter: q'
        }), 400

    try:
        results = audio_lib.search(keywords)
        formatted = audio_lib.format_for_web(results)

        return jsonify({
            'success': True,
            'query': keywords,
            'count': len(formatted),
            'results': formatted
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/play', methods=['POST'])
def play_audio():
    """
    Envoie commande CoAP pour jouer un message audio sur un node

    POST Body:
    {
        "node": "node1",           # Nom du node cible
        "message_id": 5,           # ID du message (optionnel si path fourni)
        "path": "alertes_pti/..."  # Chemin relatif (optionnel si message_id fourni)
    }
    """
    data = request.get_json()

    if not data:
        return jsonify({'success': False, 'error': 'Missing JSON body'}), 400

    node_name = data.get('node')
    message_id = data.get('message_id')
    path = data.get('path')

    if not node_name:
        return jsonify({'success': False, 'error': 'Missing node parameter'}), 400

    if not message_id and not path:
        return jsonify({
            'success': False,
            'error': 'Must provide either message_id or path'
        }), 400

    # R√©cup√©rer l'adresse IPv6 du node
    if node_name not in coap_server.registry.nodes:
        return jsonify({
            'success': False,
            'error': f'Node not found: {node_name}'
        }), 404

    node_data = coap_server.registry.nodes[node_name]
    if isinstance(node_data, dict):
        node_ip = node_data.get('address')
    else:
        node_ip = node_data

    if not node_ip:
        return jsonify({
            'success': False,
            'error': f'Node address not found: {node_name}'
        }), 404

    try:
        # Construire commande CoAP
        if message_id:
            coap_payload = f"play:{message_id}"
            msg_info = audio_lib.get_message_by_id(message_id)
            description = msg_info.get('description', '') if msg_info else ''
        else:
            # ESP32 adds /sdcard/ prefix automatically, send relative path only
            # If path ends with '/', it's a folder - find first WAV file
            if path.endswith('/'):
                import os
                folder_path = f"/Volumes/LUXWAVE/audiowav/{path}"
                if os.path.exists(folder_path) and os.path.isdir(folder_path):
                    wav_files = [f for f in os.listdir(folder_path) if f.lower().endswith('.wav')]
                    if wav_files:
                        wav_files.sort()  # Sort alphabetically to get first track
                        first_track = wav_files[0]
                        coap_payload = f"play:path:{path}{first_track}"
                        description = f"{path}{first_track}"
                    else:
                        return jsonify({
                            'success': False,
                            'error': f'No WAV files found in folder: {path}'
                        }), 404
                else:
                    return jsonify({
                        'success': False,
                        'error': f'Folder not found: {path}'
                    }), 404
            else:
                coap_payload = f"play:path:{path}"
                description = path

        # Envoyer commande via WebSocket ou CoAP selon la configuration
        if USE_WEBSOCKET_BR:
            # Mode WebSocket : envoyer via Border Router avec routing IPv6
            success = native_ws_handler.send_command_to_node(
                node_name,
                'audio',
                coap_payload
            )

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send command via Border Router'
                }), 500

            request_id = None  # IPv6 routing doesn't use request_id
        else:
            # Mode direct CoAP
            success = coap_server.send_coap_post(node_ip, 'audio', coap_payload)
            request_id = None

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send CoAP command'
                }), 500

        # √âmettre √©v√©nement WebSocket pour mise √† jour UI
        socketio.emit('audio_playback', {
            'node': node_name,
            'message_id': message_id,
            'description': description,
            'timestamp': datetime.now().isoformat(),
            'request_id': request_id
        })

        return jsonify({
            'success': True,
            'node': node_name,
            'message': description,
            'request_id': request_id
        })

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/stop', methods=['POST'])
def stop_audio():
    """Arr√™te la lecture audio sur un node"""
    data = request.get_json()

    node_name = data.get('node')
    if not node_name:
        return jsonify({'success': False, 'error': 'Missing node parameter'}), 400

    if node_name not in coap_server.registry.nodes:
        return jsonify({
            'success': False,
            'error': f'Node not found: {node_name}'
        }), 404

    node_data = coap_server.registry.nodes[node_name]
    if isinstance(node_data, dict):
        node_ip = node_data.get('address')
    else:
        node_ip = node_data

    if not node_ip:
        return jsonify({
            'success': False,
            'error': f'Node address not found: {node_name}'
        }), 404

    try:
        # Envoyer commande via WebSocket ou CoAP selon la configuration
        if USE_WEBSOCKET_BR:
            # Mode WebSocket : envoyer via Border Router avec routing IPv6
            success = native_ws_handler.send_command_to_node(
                node_name,
                'audio',
                'stop'
            )

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send command via Border Router'
                }), 500

            request_id = None  # IPv6 routing doesn't use request_id
        else:
            # Mode direct CoAP
            success = coap_server.send_coap_post(node_ip, 'audio', 'stop')
            request_id = None

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send CoAP command'
                }), 500

        return jsonify({
            'success': True,
            'node': node_name,
            'request_id': request_id
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/volume', methods=['POST'])
def set_audio_volume():
    """R√®gle le volume audio sur un node"""
    data = request.get_json()

    node_name = data.get('node')
    volume = data.get('volume')  # 0-100

    if not node_name or volume is None:
        return jsonify({
            'success': False,
            'error': 'Missing node or volume parameter'
        }), 400

    if not (0 <= volume <= 100):
        return jsonify({
            'success': False,
            'error': 'Volume must be between 0 and 100'
        }), 400

    if node_name not in coap_server.registry.nodes:
        return jsonify({
            'success': False,
            'error': f'Node not found: {node_name}'
        }), 404

    node_data = coap_server.registry.nodes[node_name]
    if isinstance(node_data, dict):
        node_ip = node_data.get('address')
    else:
        node_ip = node_data

    if not node_ip:
        return jsonify({
            'success': False,
            'error': f'Node address not found: {node_name}'
        }), 404

    try:
        # Envoyer commande via WebSocket ou CoAP selon la configuration
        if USE_WEBSOCKET_BR:
            # Mode WebSocket : envoyer via Border Router avec routing IPv6
            success = native_ws_handler.send_command_to_node(
                node_name,
                'audio',
                f'volume:{volume}'
            )

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send command via Border Router'
                }), 500

            request_id = None  # IPv6 routing doesn't use request_id
        else:
            # Mode direct CoAP
            success = coap_server.send_coap_post(node_ip, 'audio', f'volume:{volume}')
            request_id = None

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send CoAP command'
                }), 500

        return jsonify({
            'success': True,
            'node': node_name,
            'volume': volume,
            'request_id': request_id
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@socketio.on('connect')
def handle_connect():
    print('Client connect√© au WebSocket')
    emit('connected', {'message': 'Connect√© au serveur CoAP'})
    
    # Envoyer les donn√©es initiales des devices si disponibles
    if coap_server and coap_server.thingsboard.connected:
        for device_name, loc_info in coap_server.thingsboard.device_loc_code.items():
            if loc_info.get('value'):
                emit('loc_code_update', {
                    'device': device_name,
                    'loc_code': loc_info['value'],
                    'timestamp': datetime.now().isoformat()
                })

@socketio.on('disconnect')
def handle_disconnect():
    print('Client d√©connect√© du WebSocket')

@socketio.on('request_devices')
def handle_request_devices():
    """Envoie la liste des devices sur demande"""
    devices_data = []
    
    if coap_server and coap_server.thingsboard.connected:
        for device_name, device_id in coap_server.thingsboard.device_cache.items():
            loc_info = coap_server.thingsboard.device_loc_code.get(device_name, {})
            devices_data.append({
                'name': device_name,
                'id': device_id,
                'loc_code': loc_info.get('value'),
                'timestamp': loc_info.get('timestamp')
            })
    
    emit('devices_list', devices_data)


# ============================================================================
# WebSocket Namespace pour Border Routers (/ws/br)
# ============================================================================

@socketio.on('connect', namespace='/ws/br')
def handle_br_connect():
    """
    G√®re la connexion d'un Border Router via WebSocket
    Query params attendus: br_id, auth_token, network_prefix
    """
    br_id = request.args.get('br_id')
    auth_token = request.args.get('auth_token')
    network_prefix = request.args.get('network_prefix', '')

    if not br_id or not auth_token:
        logger.error("‚ùå Connexion BR refus√©e: br_id ou auth_token manquant")
        return False

    # V√©rifier l'authentification
    if BR_AUTH_ENABLED and not verify_br_token(br_id, auth_token):
        logger.error(f"‚ùå Connexion BR refus√©e: authentification √©chou√©e pour {br_id}")
        return False

    # R√©cup√©rer la config du BR (nodes associ√©s)
    br_config = get_br_config(br_id)
    nodes = br_config.get('nodes', []) if br_config else []

    # Enregistrer le BR dans le manager
    success = border_router_manager.register_br(
        br_id=br_id,
        sid=request.sid,
        network_prefix=network_prefix,
        nodes=nodes
    )

    if success:
        # Joindre la room sp√©cifique au BR
        from flask_socketio import join_room
        join_room(f'br_{br_id}')

        # Envoyer confirmation
        emit('connected', {
            'status': 'ok',
            'br_id': br_id,
            'server_time': time.time(),
            'use_websocket_mode': USE_WEBSOCKET_BR
        })

        logger.info(f"‚úÖ Border Router {br_id} connect√© via WebSocket (sid: {request.sid})")
        return True
    else:
        logger.error(f"‚ùå √âchec enregistrement BR {br_id}")
        return False


@socketio.on('disconnect', namespace='/ws/br')
def handle_br_disconnect():
    """G√®re la d√©connexion d'un Border Router"""
    br_id = border_router_manager.sid_to_br.get(request.sid)

    if br_id:
        border_router_manager.unregister_br(br_id)
        logger.warning(f"‚ö†Ô∏è Border Router {br_id} d√©connect√© (WebSocket)")


@socketio.on('heartbeat', namespace='/ws/br')
def handle_br_heartbeat(data):
    """
    G√®re le heartbeat d'un Border Router
    Data: {br_id, timestamp, nodes_count, status}
    """
    br_id = data.get('br_id')
    nodes_count = data.get('nodes_count', 0)

    if not br_id:
        return

    # Mettre √† jour le heartbeat
    border_router_manager.update_heartbeat(br_id, nodes_count)

    # R√©pondre avec ACK
    emit('heartbeat_ack', {
        'timestamp': time.time(),
        'server_status': 'ok'
    })


@socketio.on('node_event', namespace='/ws/br')
def handle_node_event(data):
    """
    G√®re les √©v√©nements des nodes ESP32 (via BR proxy)
    Data: {type, br_id, node, event_type, payload, timestamp}
    """
    try:
        br_id = data.get('br_id')
        node_name = data.get('node')
        event_type = data.get('event_type')  # 'button', 'battery', 'ble-beacon'
        payload = data.get('payload', {})

        if not br_id or not node_name or not event_type:
            logger.error("√âv√©nement node invalide: champs manquants")
            return

        # Incr√©menter le compteur d'√©v√©nements
        border_router_manager.increment_event_counter(br_id)

        # Router vers les handlers appropri√©s
        if event_type == 'button' and coap_server:
            # Adapter le format pour l'handler existant
            coap_server.handle_button_event_from_br({
                'node': node_name,
                'br_id': br_id,
                'payload': payload
            })

        elif event_type == 'battery' and coap_server:
            coap_server.handle_battery_event_from_br({
                'node': node_name,
                'br_id': br_id,
                'voltage': payload.get('voltage'),
                'percentage': payload.get('percentage')
            })

        elif event_type == 'ble_beacon' and coap_server:
            coap_server.handle_ble_event_from_br({
                'node': node_name,
                'br_id': br_id,
                'payload': payload  # Passer le payload complet
            })

        # √âmettre l'√©v√©nement aux clients web
        socketio.emit('node_event', {
            'node': node_name,
            'br_id': br_id,
            'event_type': event_type,
            'payload': payload,
            'timestamp': time.time()
        }, namespace='/')

    except Exception as e:
        logger.error(f"Erreur traitement √©v√©nement node: {e}")


@socketio.on('command_response', namespace='/ws/br')
def handle_command_response(data):
    """
    G√®re la r√©ponse √† une commande envoy√©e √† un node
    Data: {br_id, request_id, node, status, result, error}
    """
    try:
        br_id = data.get('br_id')
        request_id = data.get('request_id')
        node_name = data.get('node')
        status = data.get('status')  # 'success' ou 'error'
        result = data.get('result', {})
        error = data.get('error')

        if not request_id:
            return

        # Notifier les clients web
        socketio.emit('command_completed', {
            'request_id': request_id,
            'node': node_name,
            'br_id': br_id,
            'status': status,
            'result': result,
            'error': error,
            'timestamp': time.time()
        }, namespace='/')

        logger.info(f"üì® R√©ponse commande {request_id}: {status} (node: {node_name}, BR: {br_id})")

    except Exception as e:
        logger.error(f"Erreur traitement r√©ponse commande: {e}")


@socketio.on('topology_update', namespace='/ws/br')
def handle_topology_update(data):
    """
    G√®re la mise √† jour de topologie envoy√©e par un BR
    Data: {br_id, nodes: [{name, rloc16, role, ...}]}
    """
    try:
        br_id = data.get('br_id')
        nodes = data.get('nodes', [])

        if not br_id:
            return

        # Extraire les noms des nodes
        node_names = [n.get('name') for n in nodes if n.get('name')]

        # Mettre √† jour la liste des nodes du BR
        border_router_manager.update_nodes_list(br_id, node_names)

        logger.info(f"üó∫Ô∏è Topologie mise √† jour pour BR {br_id}: {len(node_names)} nodes")

        # Notifier les clients web
        socketio.emit('topology_update', {
            'br_id': br_id,
            'nodes_count': len(node_names)
        }, namespace='/')

    except Exception as e:
        logger.error(f"Erreur mise √† jour topologie: {e}")


# ============================================================================
# NATIVE WEBSOCKET ENDPOINT (without Socket.IO) for ESP32 Border Routers
# ============================================================================

@sock.route('/ws/br')
def border_router_websocket(ws):
    """
    Native WebSocket endpoint for ESP32 Border Router clients

    This endpoint handles plain WebSocket connections (without Socket.IO)
    for ESP32 devices using esp_websocket_client library.

    URL format:
        ws://server:port/ws/br?br_id=BR-001&auth_token=xxx&network_prefix=fd78::/64

    Messages are exchanged in plain JSON format:
        - Client -> Server: {"type": "heartbeat", "br_id": "BR-001", ...}
        - Server -> Client: {"type": "command", "target_node": "n01", ...}
    """
    from flask import request
    native_ws_handler.handle_connection(ws, request.environ)


def run_web_server():
    """Lance le serveur web dans un thread s√©par√©"""
    print(f"üåê Interface web disponible sur http://localhost:{WEB_PORT}")
    print(f"   Backend: threading (async_mode='threading')")
    socketio.run(app, host='0.0.0.0', port=WEB_PORT, debug=False, use_reloader=False, allow_unsafe_werkzeug=True)

def main():
    """Fonction principale"""
    global coap_server

    print("üöÄ Fonction main() appel√©e")

    # Cr√©er fichier exemple si n√©cessaire
    if not Path(ADDRESSES_FILE).exists():
        example_data = {
            "nodes": {
                "node_1": "fde7:cfa3:40ca:73b5:xxxx:xxxx:xxxx:xxx1",
                "node_2": "fde7:cfa3:40ca:73b5:xxxx:xxxx:xxxx:xxx2"
            }
        }
        with open(ADDRESSES_FILE, 'w') as f:
            json.dump(example_data, f, indent=2)
        print(f"üìù Fichier {ADDRESSES_FILE} cr√©√© avec des exemples")
        print("‚ö†Ô∏è  Remplacez les adresses par les vraies adresses IPv6 de vos nodes!")
        print()

    # Obtenir ou cr√©er le serveur CoAP (lazy initialization dans get_coap_server)
    # Cela fonctionne m√™me si le module est import√© plusieurs fois par les workers Flask
    coap_server = get_coap_server()
    print(f"‚úÖ CoAP Server disponible: {coap_server} (id={id(coap_server)})")

    # Initialiser le handler WebSocket natif avec les bonnes r√©f√©rences
    # Cela √©vite les imports circulaires et assure qu'on utilise la M√äME instance de socketio
    from lib import native_websocket_handler
    native_websocket_handler.init(
        app=app,
        socketio=socketio,
        coap_server=coap_server,
        border_router_manager=border_router_manager
    )

    # Lancer le serveur web dans un thread
    web_thread = threading.Thread(target=run_web_server)
    web_thread.daemon = True
    web_thread.start()

    # Mode WebSocket BR : pas de serveur CoAP direct, pas de scan topologie
    if USE_WEBSOCKET_BR:
        print("=" * 60)
        print("üîÑ MODE WEBSOCKET BORDER ROUTER ACTIV√â")
        print("=" * 60)
        print("üì° Le serveur attend les connexions WebSocket des Border Routers")
        print("   Endpoint: ws://0.0.0.0:5001/ws/br")
        print("üö´ Serveur CoAP direct d√©sactiv√© (proxy via BR)")
        print("üö´ Scan topologie Thread d√©sactiv√© (topologie via BR)")
        print("=" * 60)
        print()

        # Boucle simple pour garder le programme actif
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nüëã Arr√™t du serveur...")

    # Mode CoAP direct : lancer le serveur CoAP et le scan topologie
    else:
        print("=" * 60)
        print("üîÑ MODE COAP DIRECT ACTIV√â")
        print("=" * 60)
        print("üì° Le serveur communique directement avec les nodes Thread")
        print("‚úÖ Serveur CoAP en √©coute sur port 5683")
        print("‚úÖ Scan topologie Thread activ√©")
        print("=" * 60)
        print()

        # Lancer le scan initial de la topologie dans un thread
        print("üó∫Ô∏è  D√©marrage du scan initial de la topologie...")
        topology_thread = threading.Thread(target=refresh_topology_background)
        topology_thread.daemon = True
        topology_thread.start()

        # Lancer le serveur CoAP (boucle bloquante)
        coap_server.run()

if __name__ == "__main__":
    main()