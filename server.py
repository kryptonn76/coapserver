#!/usr/bin/env python3
"""
Serveur CoAP pour contr√¥ler les nodes ESP32 OpenThread
Version avec socket UDP simple qui fonctionne sur macOS
Int√©gration ThingsBoard pour la t√©l√©m√©trie des batteries
Int√©gration WebSocket pour recevoir les mises √† jour de t√©l√©m√©trie en temps r√©el
Cartographie automatique du r√©seau OpenThread
"""

import socket
import struct
import json
import time
import threading
import queue
from datetime import datetime
from pathlib import Path
from collections import deque
import os
import requests
from dotenv import load_dotenv

# Import ThingsBoard (optionnel)
try:
    from tb_rest_client.rest_client_ce import RestClientCE
    from tb_rest_client.rest import ApiException
    TB_AVAILABLE = True
except ImportError:
    print("‚ö†Ô∏è  Module tb_rest_client non disponible - ThingsBoard d√©sactiv√©")
    RestClientCE = None
    ApiException = None
    TB_AVAILABLE = False

from flask import Flask, render_template, jsonify, request
from flask_socketio import SocketIO, emit
from flask_cors import CORS
from flask_sock import Sock
# import logging  # Removed - using print() instead

# Configuration du logging (removed - using print() instead)
# logging.basicConfig(
#     level=logging.INFO,
#     format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
#     datefmt='%H:%M:%S'
# )

# Import ThingsBoard Location Tracker (optionnel)
try:
    from lib.thingsboard_loc_tracker import ThingsBoardLocTracker
except ImportError as e:
    print(f"‚ö†Ô∏è  Module thingsboard_loc_tracker non disponible: {e}")
    ThingsBoardLocTracker = None

import asyncio
from lib.network_topology import NetworkTopology
from lib.ot_network_mapper import OpenThreadScanner

# Import audio library
from lib.audio_library import audio_lib

# Import Border Router Management
from lib.border_router_manager import BorderRouterManager
from lib.br_auth import verify_br_token, get_br_config, get_br_nodes
import uuid

# Import nouveaux modules refactoris√©s
from lib.registry import NodeRegistry
from lib.thingsboard_client import ThingsBoardClient
from lib.tracking.badge_tracker import BadgeTracker
# ‚ö†Ô∏è CoAPClient import SUPPRIM√â - Les appels CoAP directs sont d√©sactiv√©s
# from lib.coap.client import CoAPClient
# Les fonctions de parsing sont conserv√©es pour RECEVOIR des messages CoAP (serveur uniquement)
from lib.coap.protocol import parse_coap_packet, create_coap_response

# Charger les variables d'environnement
load_dotenv()

# Configuration
COAP_PORT = 5683
ADDRESSES_FILE = "config/adresses.json"
WEB_PORT = 5001

# Border Router WebSocket Configuration
USE_WEBSOCKET_BR = os.getenv('USE_WEBSOCKET_BR', 'false').lower() == 'true'
BR_AUTH_ENABLED = os.getenv('BR_AUTH_ENABLED', 'true').lower() == 'true'
BR_HEARTBEAT_TIMEOUT = int(os.getenv('BR_HEARTBEAT_TIMEOUT', '30'))

# Log configuration at startup
print("=" * 60)
print("üîß CONFIGURATION BORDER ROUTER WEBSOCKET")
print("=" * 60)
print(f"USE_WEBSOCKET_BR:     {USE_WEBSOCKET_BR}")
print(f"BR_AUTH_ENABLED:      {BR_AUTH_ENABLED}")
print(f"BR_HEARTBEAT_TIMEOUT: {BR_HEARTBEAT_TIMEOUT}s")
print("=" * 60)

# Flask app
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key-for-demo'
CORS(app)
# Socket.IO pour les clients web (navigateur)
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='threading',
                    logger=True, engineio_logger=True)
print(f"üîç socketio id @init: {id(socketio)}, module: {__name__}")
sock = Sock(app)  # Native WebSocket support for Border Routers

# Queue thread-safe pour √©missions SocketIO depuis threads externes
# Cela √©vite le blocage des √©missions quand le serveur Flask est occup√©
socketio_queue = queue.Queue(maxsize=200)  # Buffer jusqu'√† 200 √©v√©nements
socketio_queue_running = True

def socketio_emit_worker():
    """Thread worker qui consomme la queue et √©met les √©v√©nements SocketIO

    Ce thread tourne dans le contexte Flask et peut √©mettre en continu
    sans √™tre bloqu√© par les threads externes (CoAP, etc.)
    """
    print(f"üîÑ [SOCKETIO-WORKER] Thread d√©marr√©, en attente d'√©v√©nements...")
    while socketio_queue_running:
        try:
            # Attendre un √©v√©nement (timeout 0.5s pour v√©rifier periodiquement le flag)
            event_name, event_data = socketio_queue.get(timeout=0.5)

            t_dequeue = time.time()
            print(f"üì§ [SOCKETIO-WORKER] Dequeue √©v√©nement '{event_name}' √† {t_dequeue:.3f}")

            # IMPORTANT: √âmettre dans le contexte Flask pour que SocketIO fonctionne
            with app.app_context():
                socketio.emit(event_name, event_data)

            t_emit = time.time()
            emit_delay_ms = (t_emit - t_dequeue) * 1000
            print(f"‚úÖ [SOCKETIO-WORKER] √âmission '{event_name}' termin√©e en {emit_delay_ms:.1f}ms (to all clients)")

            socketio_queue.task_done()
        except queue.Empty:
            # Pas d'√©v√©nement, continuer la boucle
            continue
        except Exception as e:
            print(f"‚ùå Erreur √©mission SocketIO worker: {e}")

# Lancer le worker thread au d√©marrage du module
socketio_worker_thread = threading.Thread(target=socketio_emit_worker, daemon=True)
socketio_worker_thread.start()

# R√©duire les logs Flask (removed - using print() instead)
# log = logging.getLogger('werkzeug')
# log.setLevel(logging.ERROR)

# Configuration ThingsBoard
TB_CONFIG = {
    'url': os.getenv('TB_URL', 'https://platform.tamtamdeals.com'),
    'username': os.getenv('TB_USERNAME', ''),
    'password': os.getenv('TB_PASSWORD', '')
}

# NodeRegistry maintenant import√© depuis lib/registry.py
# ThingsBoardClient maintenant import√© depuis lib/thingsboard_client.py

class CoAPServer:
    """
    Serveur CoAP avec socket UDP simple et int√©gration ThingsBoard WebSocket

    ‚ö†Ô∏è ARCHITECTURE CoAP:
    - Ce serveur RE√áOIT uniquement les messages CoAP des nodes (mode serveur)
    - Il NE DOIT PAS envoyer de requ√™tes CoAP directes (mode client D√âSACTIV√â)
    - Toutes les commandes aux nodes passent par les Border Routers en WebSocket:
        Python Server ‚Üí WebSocket ‚Üí Border Router ‚Üí CoAP ‚Üí Thread Node

    Les appels directs CoAP (send_coap_post) sont bloqu√©s pour garantir cette architecture.
    """

    def __init__(self, socketio_instance=None, tb_config=None):
        self.registry = NodeRegistry()
        self.running = False
        self.sock = None
        self.event_count = 0
        self.demo_mode = False
        self.battery_status = {}  # Stockage de l'√©tat batterie par node
        self.ble_detections = {}  # Stockage des d√©tections BLE beacon {code: {addr, rssi, timestamp, node}}
        self.ble_multi_detections = {}  # D√©tections multi-routeurs {badge_addr: [{node, rssi, timestamp}, ...]}
        self.badge_positions = {}  # Positions calcul√©es des badges {badge_addr: {x, y, confidence, timestamp}}
        self.node_positions = {}  # Positions des routeurs {node_name: {x, y}}
        self.name_to_rloc16 = {}  # Mapping nom‚ÜíRLOC16 (ex: "n01" ‚Üí "0x1800")
        self.ble_cache = {}  # Cache de d√©duplication globale {addr_code: timestamp}
        self.ble_history = []  # Historique complet des d√©tections pour la page web

        # Use provided socketio or fallback to global
        sio = socketio_instance if socketio_instance is not None else socketio
        tb_cfg = tb_config if tb_config is not None else TB_CONFIG

        self.thingsboard = ThingsBoardClient(
            tb_config=tb_cfg,
            socketio=sio,
            on_telemetry_update=self.handle_tb_telemetry_update,
            on_location_change=self.handle_location_change
        )  # Client ThingsBoard avec callbacks
        self.led_states = {}  # √âtat des LEDs par node
        self.led_driver_states = {}  # √âtat du LED driver (FemtoBuck) par node: {node_name: {'intensity': int}}
        self.button_events = deque(maxlen=100)  # Historique des √©v√©nements boutons
        self.node_status = {}  # √âtat g√©n√©ral des nodes
        self.tracking_mode = False  # Mode suivi de position
        self.current_tracking_node = None  # Node actuellement active en mode suivi

        # Badge sequence tracking for quality control
        self.badge_trackers = {}  # {ble_addr: BadgeTracker}

    # M√©thodes CoAP parse_coap_packet, create_coap_response et create_coap_post_packet
    # maintenant import√©es depuis lib/coap/protocol.py

    def send_coap_post(self, address, uri_path, payload):
        """
        ‚ö†Ô∏è D√âSACTIV√â - Les appels CoAP directs sont interdits!

        Cette m√©thode a √©t√© d√©sactiv√©e pour garantir que TOUTES les communications
        avec les nodes passent par les Border Routers en WebSocket.

        Architecture correcte:
          Python Server ‚Üí WebSocket ‚Üí Border Router ‚Üí CoAP ‚Üí Thread Node

        Utilisez plut√¥t:
          - send_command_via_br() pour envoyer via Border Router
          - native_ws_handler.send_command_to_node() pour les commandes
        """
        print(f"‚ùå APPEL CoAP DIRECT BLOQU√â: {address}/{uri_path} - '{payload}'")
        print(f"   ‚ö†Ô∏è  Utilisez send_command_via_br() ou le Border Router WebSocket!")
        return False

    def send_command_via_br(self, node_name, command_type, payload=None):
        """
        Envoie une commande √† un node via le Border Router en mode WebSocket

        Args:
            node_name: Nom du node cible (ex: "n01")
            command_type: Type de commande (audio_play, audio_stop, audio_volume, led_control, led_blink)
            payload: Payload de la commande (dict)

        Returns:
            tuple: (success: bool, request_id: str ou None, error: str ou None)
        """
        # Trouver le BR qui g√®re ce node
        br_id = border_router_manager.get_br_for_node(node_name)
        if not br_id:
            error_msg = f"Aucun Border Router online ne g√®re le node {node_name}"
            print(f"‚ö†Ô∏è {error_msg}")
            return False, None, error_msg

        # G√©n√©rer un request_id unique
        request_id = str(uuid.uuid4())

        # Construire le message de commande selon le protocole
        command_data = {
            'command': command_type,  # Renamed from 'type' to 'command' for clarity
            'target_node': node_name,
            'request_id': request_id,
            'payload': payload or {}
        }

        # Envoyer via WebSocket natif au BR
        try:
            success = native_ws_handler.send_command(br_id, command_data)

            if success:
                print(f"üì§ Commande {command_type} envoy√©e au BR {br_id} pour node {node_name} (request_id: {request_id})")

                # Incr√©menter le compteur de commandes
                border_router_manager.increment_command_counter(br_id)

                return True, request_id, None
            else:
                error_msg = f"BR {br_id} non connect√© ou erreur d'envoi"
                return False, None, error_msg

        except Exception as e:
            error_msg = f"Erreur envoi commande via BR: {e}"
            print(error_msg)
            return False, None, error_msg

    def handle_button_event_from_br(self, data):
        """
        Traite un √©v√©nement bouton re√ßu depuis un Border Router

        Args:
            data: Donn√©es de l'√©v√©nement (contient br_id, node, payload, timestamp)
        """
        br_id = data.get('br_id')
        node_name = data.get('node')
        payload_data = data.get('payload', {})

        print(f"üîò √âv√©nement bouton depuis BR {br_id}, node {node_name}: {payload_data}")

        # R√©cup√©rer l'adresse IPv6 du node
        node_data = self.registry.nodes.get(node_name)
        if not node_data:
            print(f"‚ùå Node {node_name} non trouv√© dans le registre")
            return

        # Extraire l'adresse (nouveau format dict ou ancien format string)
        if isinstance(node_data, dict):
            node_addr = node_data.get('address')
        else:
            node_addr = node_data  # Ancien format (compatibilit√©)

        if not node_addr:
            print(f"‚ùå Impossible de trouver l'adresse pour {node_name}")
            return

        # Extraire le type d'√©v√©nement
        event_type = payload_data.get('type', '')

        # Construire le payload au format attendu par handle_button_event
        if event_type == 'button_longpress':
            payload_str = f"longpress:{node_name}"
        elif event_type == 'button_pressed':
            payload_str = ""  # Click simple
        else:
            payload_str = ""

        # Appeler le handler existant qui contient toute la logique LED
        self.handle_button_event(node_addr, payload_str)

        # Incr√©menter le compteur d'√©v√©nements du BR
        border_router_manager.increment_event_counter(br_id)

    def handle_battery_event_from_br(self, data):
        """
        Traite un √©v√©nement batterie re√ßu depuis un Border Router

        Args:
            data: Donn√©es de l'√©v√©nement (contient br_id, node, payload, timestamp)
        """
        br_id = data.get('br_id')
        node_name = data.get('node')
        payload = data.get('payload', {})

        voltage = payload.get('voltage', 0)
        percentage = payload.get('percentage', 0)

        print(f"üîã Batterie depuis BR {br_id}, node {node_name}: {voltage}V ({percentage}%)")

        # Stocker l'√©tat batterie
        self.battery_status[node_name] = {
            'voltage': voltage,
            'percentage': percentage,
            'timestamp': datetime.now().isoformat(),
            'br_id': br_id
        }

        # √âmettre via WebSocket
        socketio.emit('battery_update', {
            'node': node_name,
            'voltage': voltage,
            'percentage': percentage,
            'timestamp': datetime.now().isoformat()
        })

        # Incr√©menter le compteur d'√©v√©nements du BR
        border_router_manager.increment_event_counter(br_id)

    def handle_ble_event_from_br(self, data):
        """
        Traite un √©v√©nement BLE beacon re√ßu depuis un Border Router

        Args:
            data: Donn√©es de l'√©v√©nement (contient br_id, node, payload, timestamp)
        """
        br_id = data.get('br_id')
        node_name = data.get('node')
        payload = data.get('payload', {})

        # R√©cup√©rer l'adresse BLE et le RSSI depuis le payload
        ble_addr = payload.get('ble_addr', '')
        rssi = payload.get('rssi', 0)
        code = payload.get('code', '')

        print(f"üì° BLE beacon depuis BR {br_id}, node {node_name}: {ble_addr} (RSSI: {rssi}, code: {code})")

        # Stocker la d√©tection
        detection_data = {
            'node': node_name,
            'br_id': br_id,
            'device': ble_addr,  # Chang√© de 'ble_addr' √† 'device' pour correspondre au JS
            'rssi': rssi,
            'code': code,
            'timestamp': datetime.now().isoformat()
        }

        # Ajouter √† l'historique
        self.ble_history.append(detection_data)

        # Limiter l'historique √† 1000 entr√©es
        if len(self.ble_history) > 1000:
            self.ble_history.pop(0)

        # Mettre √† jour le cache de d√©tection
        if code:
            self.ble_detections[code] = detection_data

        # Stocker dans multi-d√©tections pour triangulation (fen√™tre de 5 secondes)
        now = time.time()
        if ble_addr not in self.ble_multi_detections:
            self.ble_multi_detections[ble_addr] = []

        # Ajouter la nouvelle d√©tection
        self.ble_multi_detections[ble_addr].append({
            'node': node_name,
            'rssi': rssi,
            'timestamp': now,
            'code': code
        })

        # Nettoyer les d√©tections > 5 secondes
        self.ble_multi_detections[ble_addr] = [
            d for d in self.ble_multi_detections[ble_addr]
            if (now - d['timestamp']) < 5.0
        ]

        # Calculer et √©mettre la position du badge
        print(f"üîç DEBUG BR-WS: Appel calculate_and_emit_badge_position() pour {code}")
        self.calculate_and_emit_badge_position(ble_addr, code)
        print(f"‚úÖ DEBUG BR-WS: Retour de calculate_and_emit_badge_position()")

        # √âmettre via WebSocket (utiliser start_background_task pour thread-safety)
        def _emit_ble_events():
            print(f"üîç socketio id @emit: {id(socketio)}, module: {__name__}")
            print(f"üì§ √âmission 'ble_beacon' et 'ble_frame' via SocketIO...")
            socketio.emit('ble_beacon', detection_data, namespace='/')
            socketio.emit('ble_frame', frame_data, namespace='/')
            print(f"‚úÖ √âv√©nements Socket.IO √©mis avec succ√®s")

        # Pr√©parer frame_data pour la page debug
        frame_data = {
            'router': node_name,
            'code': code,
            'badge_addr': ble_addr,
            'rssi': rssi if rssi else 0,
            'timestamp': datetime.now().isoformat()
        }

        # Lancer l'√©mission dans une t√¢che background Socket.IO
        socketio.start_background_task(_emit_ble_events)

        # Incr√©menter le compteur d'√©v√©nements du BR
        border_router_manager.increment_event_counter(br_id)

    def handle_button_event(self, source_addr, payload, flash_duration=2, demo_mode=False):
        """Traite un √©v√©nement bouton"""
        node_name = self.registry.get_node_by_address(source_addr)
        if not node_name:
            node_name = "unknown"
        
        # Cr√©er l'√©v√©nement pour le web
        event_data = {
            'node': node_name,
            'address': source_addr,
            'timestamp': datetime.now().isoformat(),
            'type': 'button'
        }
        
        # V√©rifier si c'est un √©v√©nement long press
        if payload and payload.startswith("longpress:"):
            # Extraire l'ID du node
            node_id = payload.split(":", 1)[1] if ":" in payload else ""
            print(f"\nüîòüîò BOUTON LONG PRESS par {node_name} ({source_addr})")
            print(f"   Node ID: {node_id}")
            
            # R√©cup√©rer l'√©tat actuel de la LED du node source
            current_state = self.led_states.get(source_addr, {}).get('light', False)
            new_state = not current_state
            
            print(f"   √âtat actuel de la LED source: {'ON' if current_state else 'OFF'}")
            print(f"   ‚Üí Toggle toutes les LEDs vers: {'ON' if new_state else 'OFF'}")

            # Envoyer la commande √† tous les nodes via Border Router
            action = 'on' if new_state else 'off'
            intensity = 100 if new_state else 0
            success_count = 0

            for name in self.registry.nodes.keys():
                success, request_id, error = self.send_command_via_br(name, 'led_driver', {
                    'action': action,
                    'intensity': intensity
                })

                if success:
                    success_count += 1
                    # Mettre √† jour √©tat LED driver local
                    if name not in self.led_driver_states:
                        self.led_driver_states[name] = {}
                    self.led_driver_states[name]['intensity'] = intensity

                    # Mettre √† jour √©tat LED legacy
                    node_data = self.registry.nodes.get(name)
                    if isinstance(node_data, dict):
                        addr = node_data.get('address')
                    else:
                        addr = node_data
                    if addr:
                        if addr not in self.led_states:
                            self.led_states[addr] = {}
                        self.led_states[addr]['light'] = new_state

            print(f"   ‚úÖ {success_count}/{len(self.registry.nodes)} nodes synchronis√©s")
            
            event_data['action'] = 'longpress'
            event_data['node_id'] = node_id
            event_data['global_led_state'] = new_state
            
            # √âmettre l'√©v√©nement WebSocket
            socketio.emit('button_event', event_data)
            self.button_events.append(event_data)
            
            # √âmettre les mises √† jour LED pour tous les nodes
            for name, node_data in self.registry.nodes.items():
                if isinstance(node_data, dict):
                    addr = node_data.get('address')
                else:
                    addr = node_data
                
                if addr:
                    socketio.emit('led_update', {
                        'node': name,
                        'led': 'light',
                        'state': new_state
                    })
            
            return
        
        # √âv√©nement click normal
        print(f"\nüîò BOUTON PRESS√â par {node_name} ({source_addr})")
        print(f"   Payload: {payload}")
        
        event_data['action'] = 'click'
        event_data['payload'] = payload
        
        # Toggle la LED du node qui a envoy√© l'√©v√©nement
        print(f"üí° Toggle LED sur {node_name}...")
        
        # G√©rer l'√©tat de la LED pour ce node
        if not hasattr(self, 'led_states'):
            self.led_states = {}
        
        # Toggle l'√©tat
        current_state = self.led_states.get(source_addr, {}).get('light', False)
        new_state = not current_state
        
        if source_addr not in self.led_states:
            self.led_states[source_addr] = {}
        self.led_states[source_addr]['light'] = new_state
        
        # Envoyer la commande via Border Router
        action = 'on' if new_state else 'off'
        intensity = 100 if new_state else 0
        success, request_id, error = self.send_command_via_br(node_name, 'led_driver', {
            'action': action,
            'intensity': intensity
        })

        if success:
            print(f"   ‚Üí LED {node_name}: {'ON' if new_state else 'OFF'}")
            # Mettre √† jour √©tat LED driver local
            if node_name not in self.led_driver_states:
                self.led_driver_states[node_name] = {}
            self.led_driver_states[node_name]['intensity'] = intensity
        else:
            print(f"   ‚ùå √âchec envoi commande LED: {error}")
        
        # √âmettre l'√©v√©nement WebSocket
        event_data['led_state'] = new_state
        socketio.emit('button_event', event_data)
        self.button_events.append(event_data)
        
        # Mettre √† jour l'√©tat du node
        socketio.emit('led_update', {
            'node': node_name,
            'led': 'light',
            'state': new_state
        })
    
    def handle_server_id(self, source_addr, payload):
        """Traite une demande server-id"""
        print(f"üì° Requ√™te server-id de {source_addr}: {payload}")
        # Le node conna√Æt maintenant notre adresse
        
    def handle_battery_report(self, source_addr, payload):
        """Traite un rapport de batterie"""
        node_name = self.registry.get_node_by_address(source_addr)
        if not node_name:
            node_name = f"unknown_{source_addr[:8]}"
        
        # Parser le payload "12.45V:95"
        try:
            parts = payload.split(':')
            if len(parts) >= 2:
                voltage_str = parts[0].rstrip('V')
                percentage_str = parts[1]
                voltage = float(voltage_str)
                percentage = int(percentage_str)
                
                # Stocker l'√©tat batterie
                if node_name not in self.battery_status:
                    self.battery_status[node_name] = {
                        'history': deque(maxlen=10),  # Garder les 10 derni√®res mesures
                        'current': None
                    }
                
                battery_data = {
                    'timestamp': datetime.now(),
                    'voltage': voltage,
                    'percentage': percentage
                }
                
                self.battery_status[node_name]['current'] = battery_data
                self.battery_status[node_name]['history'].append(battery_data)
                
                # Afficher l'√©tat
                timestamp = datetime.now().strftime("%H:%M:%S")
                status_icon = "üîã" if percentage > 20 else "ü™´"
                print(f"\n{status_icon} [{timestamp}] Batterie {node_name}: {voltage:.2f}V ({percentage}%)")
                
                # Alerte si batterie faible
                if percentage < 20:
                    print(f"   ‚ö†Ô∏è  ATTENTION: Batterie faible sur {node_name}!")
                
                # √âmettre l'√©tat batterie via WebSocket
                socketio.emit('battery_update', {
                    'node': node_name,
                    'voltage': voltage,
                    'percentage': percentage,
                    'timestamp': datetime.now().isoformat(),
                    'low_battery': percentage < 20
                })
                
                # Envoyer √† ThingsBoard
                if self.thingsboard.connected:
                    self.thingsboard.send_battery_telemetry(node_name, voltage, percentage)
                    
            else:
                print(f"‚ùå Format de payload batterie invalide: {payload}")
                
        except Exception as e:
            print(f"‚ùå Erreur parsing batterie: {e} (payload: {payload})")

    def handle_ble_beacon(self, source_addr, payload):
        """Traite une d√©tection BLE beacon avec d√©duplication intelligente

        Logique:
        - Cache par balise (code+adresse) avec timeout 5s
        - Changement de code = reset du cache pour cette balise
        - Protection anti-retard: ancien code < 1s apr√®s nouveau code = ignor√©
        """
        t_receive = time.time()
        node_name = self.registry.get_node_by_address(source_addr)
        if not node_name:
            node_name = f"unknown_{source_addr[:8]}"

        try:
            # Parser le JSON payload
            data = json.loads(payload)
            code = data.get('code', '')
            ble_addr = data.get('addr', '')
            rssi = data.get('rssi', 0)
            timestamp_ms = data.get('timestamp', 0)

            print(f"üì• [COAP-RX] Trame BLE re√ßue: {code} @ {t_receive:.3f} (rssi={rssi}dBm)")

            # √âmettre TOUTES les trames pour debug (avant d√©duplication)
            # Utiliser la queue thread-safe pour √©mission depuis thread CoAP
            try:
                t_before_queue = time.time()
                socketio_queue.put_nowait(('ble_frame', {
                    'router': node_name,
                    'code': code,
                    'badge_addr': ble_addr,
                    'rssi': rssi,
                    'timestamp': datetime.now().isoformat()
                }))
                t_after_queue = time.time()
                queue_delay_us = (t_after_queue - t_before_queue) * 1000000
                queue_size = socketio_queue.qsize()
                print(f"üì® [COAP-RX] Trame {code} enqueue en {queue_delay_us:.0f}¬µs (queue={queue_size}/200)")
            except queue.Full:
                print(f"‚ö†Ô∏è Queue SocketIO pleine, trame BLE perdue")

            cache_key = f"{ble_addr}_{code}"
            now = time.time()

            # V√©rifier si on a d√©j√† vu cette balise (n'importe quel code)
            beacon_prefix = f"{ble_addr}_"
            last_code = None
            last_time = None

            for key, timestamp in list(self.ble_cache.items()):
                if key.startswith(beacon_prefix):
                    last_code = key.split('_', 1)[1]
                    last_time = timestamp

                    # Changement de code d√©tect√©
                    if last_code != code:
                        # Avec √©mission 1x/seconde, accepter les paquets m√™me en retard
                        # (pas de double √©mission BLE donc pas de risque de duplicate)
                        del self.ble_cache[key]
                        break
                    else:
                        # M√™me code re√ßu deux fois
                        time_diff = (now - last_time)
                        if time_diff < 1.0:
                            # Duplicate r√©cent, ignorer
                            return
                        else:
                            # Timeout expir√© (>1s), accepter
                            del self.ble_cache[key]
                            break

            # Mettre √† jour le cache avec le nouveau code
            self.ble_cache[cache_key] = now

            # Track sequence for quality control
            if ble_addr not in self.badge_trackers:
                self.badge_trackers[ble_addr] = BadgeTracker(ble_addr)

            tracker = self.badge_trackers[ble_addr]
            previous_code = tracker.last_code  # Save before check_sequence updates it
            is_valid, gap = tracker.check_sequence(code, now)

            # Log sequence errors (only if frames actually missed)
            if not is_valid and previous_code and gap > 0:
                print(f"‚ö†Ô∏è  Badge {ble_addr[-8:]}: Sequence break {previous_code} ‚Üí {code} "
                      f"({gap} frame{'s' if gap > 1 else ''} missed)")

            # Stocker la d√©tection actuelle
            detection_time = datetime.now()
            self.ble_detections[ble_addr] = {
                'code': code,
                'addr': ble_addr,
                'rssi': rssi,
                'timestamp': detection_time,
                'node': node_name
            }

            # Stocker dans multi-d√©tections pour triangulation (fen√™tre de 3 secondes)
            if ble_addr not in self.ble_multi_detections:
                self.ble_multi_detections[ble_addr] = []

            # Ajouter la nouvelle d√©tection
            self.ble_multi_detections[ble_addr].append({
                'node': node_name,
                'rssi': rssi,
                'timestamp': now,
                'code': code
            })

            # Nettoyer les d√©tections > 5 secondes
            self.ble_multi_detections[ble_addr] = [
                d for d in self.ble_multi_detections[ble_addr]
                if (now - d['timestamp']) < 5.0
            ]

            # Calculer et √©mettre la position du badge
            print(f"üîç DEBUG: Appel calculate_and_emit_badge_position() pour {code}")
            self.calculate_and_emit_badge_position(ble_addr, code)
            print(f"‚úÖ DEBUG: Retour de calculate_and_emit_badge_position()")

            # Ajouter √† l'historique (limit√© aux 1000 derni√®res d√©tections)
            self.ble_history.append({
                'timestamp': detection_time.isoformat(),
                'device': ble_addr,
                'code': code,
                'node': node_name,
                'rssi': rssi
            })
            if len(self.ble_history) > 1000:
                self.ble_history.pop(0)

            # Ne plus logger dans le terminal (affichage via page web)

            # √âmettre via WebSocket
            # Utiliser la queue thread-safe pour √©mission depuis thread CoAP
            try:
                socketio_queue.put_nowait(('ble_beacon', {
                    'device': ble_addr,
                    'code': code,
                    'rssi': rssi,
                    'node': node_name,
                    'timestamp': detection_time.isoformat()
                }))
            except queue.Full:
                print(f"‚ö†Ô∏è Queue SocketIO pleine, beacon BLE perdu")

        except json.JSONDecodeError as e:
            print(f"‚ùå Erreur JSON parsing BLE beacon: {e} (payload: {payload})")
        except Exception as e:
            print(f"‚ùå Erreur parsing BLE beacon: {e} (payload: {payload})")

    def calculate_and_emit_badge_position(self, badge_addr, code):
        """Calcule la position d'un badge par triangulation RSSI et √©met via WebSocket"""
        try:
            detections = self.ble_multi_detections.get(badge_addr, [])
            print(f"üîç DEBUG badge {code}: {len(detections)} d√©tections totales")

            # Accepter au moins 1 router (anciennement 2 pour triangulation)
            if len(detections) < 1:
                print(f"   ‚ùå Aucune d√©tection, abandon")
                return

            # Filtrer pour garder d√©tections tr√®s r√©centes (< 1 seconde)
            now = time.time()
            recent_detections = [d for d in detections if (now - d['timestamp']) < 1.0]
            print(f"   üîç {len(recent_detections)} d√©tections r√©centes (< 1s)")

            if len(recent_detections) < 1:
                print(f"   ‚ùå Aucune d√©tection r√©cente, abandon")
                return

            # IMPORTANT: Garder uniquement la MEILLEURE d√©tection par routeur (√©viter duplicates)
            # Grouper par node et garder le meilleur RSSI pour chaque routeur
            best_by_router = {}
            for d in recent_detections:
                node = d['node']
                if node not in best_by_router or d['rssi'] > best_by_router[node]['rssi']:
                    best_by_router[node] = d

            # Convertir en liste
            unique_detections = list(best_by_router.values())
            router_names = [d['node'] for d in unique_detections]
            print(f"   üîç {len(unique_detections)} routeurs uniques: {router_names}")

            if len(unique_detections) < 1:
                print(f"   ‚ùå Aucun routeur unique, abandon")
                return

            # Trier par RSSI (meilleurs signaux en premier) et garder top 5 routeurs
            unique_detections.sort(key=lambda d: d['rssi'], reverse=True)
            top_detections = unique_detections[:5]
            print(f"   ‚úÖ {len(top_detections)} routeurs pour calcul position")

            # CAS SP√âCIAL: 1 seul router d√©tecte le badge
            # ‚Üí Juxtaposer le badge au node avec un offset al√©atoire
            if len(top_detections) == 1:
                detection = top_detections[0]
                node_name = detection['node']
                rssi = detection['rssi']

                # R√©cup√©rer position du node
                node_pos = self.node_positions.get(node_name)
                if not node_pos:
                    # Chercher par RLOC16 si pas trouv√© par nom
                    rloc16 = self.name_to_rloc16.get(node_name)
                    if rloc16:
                        node_pos = self.node_positions.get(rloc16)

                if not node_pos:
                    print(f"‚ö†Ô∏è Badge {code}: 1 router ({node_name}) mais pas de position connue - abandon")
                    return

                # Juxtaposer badge au node avec offset al√©atoire (¬±20-30 pixels)
                import random
                offset_x = random.uniform(-30, 30)
                offset_y = random.uniform(-30, 30)

                pos_x = node_pos['x'] + offset_x
                pos_y = node_pos['y'] + offset_y
                confidence = 50  # Confidence moyenne (1 seul router)

                # Stocker position
                self.badge_positions[badge_addr] = {
                    'x': pos_x,
                    'y': pos_y,
                    'confidence': confidence,
                    'timestamp': datetime.now()
                }

                # √âmettre via WebSocket
                socketio.emit('badge_position', {
                    'badge_addr': badge_addr,
                    'code': code,
                    'x': pos_x,
                    'y': pos_y,
                    'confidence': confidence,
                    'rssi_values': {node_name: rssi},
                    'nb_routers': 1,
                    'timestamp': datetime.now().isoformat()
                })

                print(f"üìç {code}: ({pos_x:.0f},{pos_y:.0f}) {confidence}% [1 router: {node_name}]")
                return

            # CAS NORMAL: 2+ routers ‚Üí Triangulation par barycentre pond√©r√© RSSI
            total_weight = 0
            weighted_x = 0
            weighted_y = 0
            rssi_values = {}
            nodes_with_position = []

            for detection in top_detections:
                node_name = detection['node']
                rssi = detection['rssi']
                rssi_values[node_name] = rssi

                # R√©cup√©rer position du node (chercher par nom OU par RLOC16)
                node_pos = self.node_positions.get(node_name)

                # Si pas trouv√© par nom, chercher le RLOC16 correspondant
                if not node_pos:
                    # Trouver le RLOC16 √† partir du nom via le mapping
                    rloc16 = self.name_to_rloc16.get(node_name)
                    if rloc16:
                        node_pos = self.node_positions.get(rloc16)

                if not node_pos:
                    continue

                nodes_with_position.append(node_name)

                # Pond√©ration: w = 10^(RSSI/20) (en dB logarithmique)
                # RSSI typique: -30 dBm (proche) √† -80 dBm (loin)
                weight = 10 ** (rssi / 20.0)

                weighted_x += node_pos['x'] * weight
                weighted_y += node_pos['y'] * weight
                total_weight += weight

            if total_weight == 0:
                return

            # Position finale
            pos_x = weighted_x / total_weight
            pos_y = weighted_y / total_weight

            # Confidence bas√©e sur nombre de routeurs
            confidence = min(100, len(top_detections) * 25)  # 2‚Üí50%, 3‚Üí75%, 4+‚Üí100%

            # Stocker position
            self.badge_positions[badge_addr] = {
                'x': pos_x,
                'y': pos_y,
                'confidence': confidence,
                'timestamp': datetime.now()
            }

            # √âmettre via WebSocket
            socketio.emit('badge_position', {
                'badge_addr': badge_addr,
                'code': code,
                'x': pos_x,
                'y': pos_y,
                'confidence': confidence,
                'rssi_values': rssi_values,
                'nb_routers': len(top_detections),
                'timestamp': datetime.now().isoformat()
            })

            # Log concis: code, routeurs, position
            router_list = ', '.join(nodes_with_position)
            print(f"üìç {code}: ({pos_x:.0f},{pos_y:.0f}) {confidence}% [{router_list}]")

        except Exception as e:
            print(f"‚ùå Erreur triangulation {code}: {e}")

    def announce_server(self, flash_yellow=False):
        """Annonce l'adresse du serveur √† tous les nodes"""
        print("\nüì¢ Annonce du serveur aux nodes...")
        
        addresses = self.registry.get_all_addresses()
        if not addresses:
            print("‚ö†Ô∏è Aucun node configur√© dans adresses.json")
            return
        
        # Si demand√©, allumer les LEDs rouges (anciennement jaunes)
        if flash_yellow:
            print("üíõ Allumage des LEDs rouges...")
            for addr in addresses:
                self.send_coap_post(addr, "led", "red:on")
        
        # Envoyer server-id √† chaque node
        success_count = 0
        for name, node_data in self.registry.nodes.items():
            # G√©rer le nouveau format avec dictionnaire
            if isinstance(node_data, dict):
                addr = node_data.get('address')
            else:
                # Ancien format (compatibilit√©)
                addr = node_data
            
            if addr and self.send_coap_post(addr, "server-id", "server-id"):
                print(f"  ‚úì Annonce envoy√©e √† {name}")
                success_count += 1
            else:
                print(f"  ‚ùå √âchec annonce √† {name}")
        
        print(f"üì° Annonce termin√©e: {success_count}/{len(addresses)} nodes contact√©s")
        
        # Si on a allum√© les LEDs rouges, les √©teindre apr√®s 1 seconde
        if flash_yellow:
            def turn_off_red():
                time.sleep(1)
                for addr in addresses:
                    self.send_coap_post(addr, "led", "red:off")
                print("üíõ LEDs rouges √©teintes")
            
            threading.Thread(target=turn_off_red).start()
    
    def delayed_announce(self):
        """Annonce le serveur apr√®s un d√©lai"""
        time.sleep(2)  # Attendre que le serveur soit bien d√©marr√©
        print("\nüîÑ Annonce automatique du serveur...")
        self.announce_server()
    
    def demo_loop(self):
        """Boucle de d√©monstration"""
        print("\nüé≠ MODE D√âMO ACTIV√â")
        print("   - Flash LED rouge : 500ms ON / 500ms OFF")
        print("   - Annonce serveur : toutes les 30s")
        print("   - Tapez 'stop' ou Ctrl+C pour arr√™ter\n")
        
        last_announce = time.time()
        announce_interval = 30  # secondes
        
        flash_count = 0
        while self.demo_mode and self.running:
            try:
                current_time = time.time()
                
                # V√©rifier si on doit faire une annonce (toutes les 30 secondes)
                if current_time - last_announce >= announce_interval:
                    # ‚ö†Ô∏è D√âSACTIV√â - Les appels CoAP directs sont interdits
                    print(f"\r[{datetime.now().strftime('%H:%M:%S')}] ‚ö†Ô∏è  Annonce serveur D√âSACTIV√âE (CoAP direct bloqu√©)")
                    # NOTE: Cette fonctionnalit√© doit √™tre r√©impl√©ment√©e via Border Router WebSocket
                    # # Annonce silencieuse
                    # addresses = self.registry.get_all_addresses()
                    # if addresses:
                    #     # Cr√©er un socket temporaire pour l'envoi
                    #     sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
                    #     try:
                    #         # Flash jaune
                    #         for addr in addresses:
                    #             sock.sendto(create_coap_post_packet("led", "yellow:on"), (addr, COAP_PORT))
                    #         # Envoyer server-id
                    #         for name, addr in self.registry.nodes.items():
                    #             packet = create_coap_post_packet("server-id", "server-id")
                    #             sock.sendto(packet, (addr, COAP_PORT))
                    #         time.sleep(1)
                    #         # √âteindre jaune
                    #         for addr in addresses:
                    #             sock.sendto(create_coap_post_packet("led", "yellow:off"), (addr, COAP_PORT))
                    #     finally:
                    #         sock.close()
                    last_announce = current_time
                
                # Flash continu des LEDs rouges - ‚ö†Ô∏è D√âSACTIV√â (CoAP direct bloqu√©)
                # NOTE: Cette fonctionnalit√© doit √™tre r√©impl√©ment√©e via Border Router WebSocket
                # addresses = self.registry.get_all_addresses()
                # if addresses:
                #     # Cr√©er un socket temporaire pour l'envoi
                #     sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
                #     try:
                #         # Allumer
                #         for addr in addresses:
                #             sock.sendto(create_coap_post_packet("led", "red:on"), (addr, COAP_PORT))
                #         time.sleep(0.5)
                #         # √âteindre
                #         for addr in addresses:
                #             sock.sendto(create_coap_post_packet("led", "red:off"), (addr, COAP_PORT))
                #         time.sleep(0.5)
                #     finally:
                #         sock.close()
                time.sleep(1.0)  # Attendre au lieu de flasher
                
                # Afficher un indicateur tournant pour montrer que le d√©mo est actif
                flash_count += 1
                spinner = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
                print(f"\r{spinner[flash_count % len(spinner)]} Mode d√©mo actif... (stop ou Ctrl+C pour arr√™ter)", end='', flush=True)
                    
            except Exception as e:
                print(f"\r‚ùå Erreur dans le mode d√©mo: {e}")
                self.demo_mode = False
        
        print("\rüé≠ Mode d√©mo d√©sactiv√©                                          ")
    
    def handle_location_change(self, loc_code: str):
        """Handler pour les changements de localisation - g√®re le mode suivi de position"""
        try:
            # Chercher si le loc_code correspond √† un node connu
            node_name = None
            
            # Essayer de mapper le loc_code vers un nom de node
            # Par exemple: "s1Z" -> node "s1Z" ou chercher dans les adresses
            for name, node_data in self.registry.nodes.items():
                # V√©rifier si le nom du node correspond au loc_code
                if name.lower() == loc_code.lower():
                    node_name = name
                    break
                # Ou si le loc_code est dans le nom
                elif loc_code.lower() in name.lower():
                    node_name = name
                    break
            
            # V√©rifier si le node est connu et a une adresse
            node_address = None
            if node_name and node_name in self.registry.nodes:
                node_data = self.registry.nodes[node_name]
                if isinstance(node_data, dict):
                    node_address = node_data.get('address')
                else:
                    node_address = node_data
            
            # Si c'est un node connu avec une adresse
            if node_name and node_address:
                # Si le mode suivi est actif
                if self.tracking_mode:
                    print(f"\nüéØ Mode Suivi: Changement vers node {node_name}")
                    
                    # Si c'est une nouvelle node
                    if self.current_tracking_node != node_name:
                        self.current_tracking_node = node_name
                        
                        # Obtenir les nodes connexes
                        connected_nodes = self.registry.get_connected_nodes(node_name)
                        all_nodes = self.registry.get_all_node_names()
                        
                        print(f"   Nodes connexes de {node_name}: {connected_nodes}")
                        
                        # Flash LED rouge de la node active (200ms)
                        def flash_red():
                            self.send_coap_post(node_address, "led", "red:on")
                            time.sleep(0.2)
                            self.send_coap_post(node_address, "led", "red:off")
                        
                        # Lancer le flash dans un thread pour ne pas bloquer
                        flash_thread = threading.Thread(target=flash_red)
                        flash_thread.daemon = True
                        flash_thread.start()
                        
                        # Pour chaque node, allumer ou √©teindre selon si elle est connexe
                        for node in all_nodes:
                            if node == node_name:
                                continue  # Skip la node active
                            
                            node_data = self.registry.nodes.get(node, {})
                            if isinstance(node_data, dict):
                                addr = node_data.get('address')
                                if addr:
                                    if node in connected_nodes:
                                        # Allumer les nodes connexes
                                        print(f"   üí° Allumer node connexe: {node}")
                                        self.send_coap_post(addr, "led", "light:on")
                                        if addr not in self.led_states:
                                            self.led_states[addr] = {}
                                        self.led_states[addr]['light'] = True
                                    else:
                                        # √âteindre les nodes non-connexes
                                        print(f"   üîå √âteindre node non-connexe: {node}")
                                        self.send_coap_post(addr, "led", "light:off")
                                        if addr not in self.led_states:
                                            self.led_states[addr] = {}
                                        self.led_states[addr]['light'] = False
                        
                        # √âmettre un √©v√©nement pour l'interface web
                        tracking_event = {
                            'type': 'tracking_update',
                            'active_node': node_name,
                            'connected_nodes': connected_nodes,
                            'timestamp': datetime.now().isoformat()
                        }
                        socketio.emit('tracking_update', tracking_event)
                else:
                    # Mode normal : faire un flash de la LED rouge
                    print(f"üî¥ Envoi flash LED rouge au node {node_name} ({node_address})")
                    try:
                        # Allumer la LED rouge
                        self.send_coap_post(node_address, "led", "red:on")
                        
                        # Attendre 200ms
                        time.sleep(0.2)
                        
                        # √âteindre la LED rouge
                        self.send_coap_post(node_address, "led", "red:off")
                        
                        print(f"   ‚úÖ Flash LED rouge termin√©")
                    except Exception as e:
                        print(f"   ‚ùå Erreur envoi commande: {e}")
            else:
                print(f"‚ö†Ô∏è Node inconnu ou sans adresse pour loc_code: {loc_code} (ignor√©)")
                
        except Exception as e:
            print(f"‚ùå Erreur dans handle_location_change: {e}")
    
    def handle_tb_telemetry_update(self, node_name: str, telemetry: dict):
        """Handler pour les mises √† jour de t√©l√©m√©trie re√ßues depuis ThingsBoard WebSocket"""
        try:
            # D√©sactiv√© pour r√©duire le bruit - ce sont les updates re√ßues DE ThingsBoard
            # print(f"üîÑ Mise √† jour ThingsBoard pour {node_name}: {telemetry}")
            
            # G√©rer les mises √† jour loc_code
            if 'loc_code' in telemetry:
                # √âmettre via Socket.IO pour l'interface web
                socketio.emit('loc_code_update', {
                    'device': node_name,
                    'loc_code': telemetry['loc_code'],
                    'timestamp': datetime.now().isoformat()
                })
            
            # Mettre √† jour l'√©tat batterie si pr√©sent
            if 'battery_level' in telemetry or 'battery_value' in telemetry:
                battery_info = self.battery_status.get(node_name, {})
                
                if 'battery_level' in telemetry:
                    battery_info['percentage'] = telemetry['battery_level']
                if 'battery_value' in telemetry:
                    battery_info['voltage'] = telemetry['battery_value']
                    
                battery_info['timestamp'] = datetime.now()
                self.battery_status[node_name] = battery_info
                
                # √âmettre via Socket.IO pour l'interface web
                socketio.emit('battery_update', {
                    'node': node_name,
                    'voltage': battery_info.get('voltage', 0),
                    'percentage': battery_info.get('percentage', 0),
                    'timestamp': battery_info['timestamp'].isoformat()
                })
            
            # Mettre √† jour l'√©tat des LEDs si pr√©sent
            if 'led_state' in telemetry:
                led_states = telemetry['led_state']
                if node_name in self.registry.nodes:
                    node_data = self.registry.nodes[node_name]
                    addr = node_data.get('address') if isinstance(node_data, dict) else node_data
                    
                    if addr not in self.led_states:
                        self.led_states[addr] = {}
                    
                    # Parser l'√©tat des LEDs (format attendu: {"red": true/false, "light": true/false})
                    if isinstance(led_states, dict):
                        for led, state in led_states.items():
                            self.led_states[addr][led] = state
                            
                            # √âmettre via Socket.IO
                            socketio.emit('led_update', {
                                'node': node_name,
                                'led': led,
                                'state': state
                            })
            
            # Traiter les √©v√©nements bouton
            if 'button_state' in telemetry:
                button_state = telemetry['button_state']
                
                # Cr√©er un √©v√©nement bouton
                event = {
                    'node': node_name,
                    'timestamp': datetime.now().isoformat(),
                    'type': 'button',
                    'state': button_state
                }
                
                self.button_events.append(event)
                self.event_count += 1
                
                # √âmettre via Socket.IO
                socketio.emit('button_event', event)
            
            # Autres donn√©es de t√©l√©m√©trie (temp√©rature, humidit√©, etc.)
            if 'temperature' in telemetry or 'humidity' in telemetry:
                socketio.emit('telemetry_update', {
                    'node': node_name,
                    'data': telemetry,
                    'timestamp': datetime.now().isoformat()
                })
                
        except Exception as e:
            print(f"‚ùå Erreur traitement t√©l√©m√©trie ThingsBoard: {e}")
    
    def run(self):
        """Lance le serveur"""
        print("üåê Serveur CoAP de contr√¥le")
        print(f"   Port: {COAP_PORT}")
        print("=" * 50)
        
        # Connexion √† ThingsBoard si configur√©
        if TB_CONFIG['username'] and TB_CONFIG['password']:
            self.thingsboard.connect()
        else:
            print("‚ÑπÔ∏è ThingsBoard non configur√© (d√©finir TB_USERNAME et TB_PASSWORD)")
        
        # Socket UDP IPv6
        self.sock = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        
        try:
            self.sock.bind(('::', COAP_PORT))
            print("‚úì Serveur d√©marr√© sur toutes les interfaces IPv6")
        except:
            # Fallback sur IPv4
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sock.bind(('', COAP_PORT))
            print("‚úì Serveur d√©marr√© en IPv4")
        
        print("\nüìç Ressources disponibles:")
        print("   - /button : re√ßoit les √©v√©nements button-pressed")
        print("   - /server-id : enregistrement des nodes")
        print("   - /battery : re√ßoit les rapports de batterie")
        print("   - /ble-beacon : re√ßoit les d√©tections BLE beacon")
        
        self.running = True
        
        # Thread pour les commandes interactives
        cmd_thread = threading.Thread(target=self.command_loop)
        cmd_thread.daemon = True
        cmd_thread.start()
        
        # Annoncer le serveur aux nodes apr√®s un court d√©lai
        announce_thread = threading.Thread(target=self.delayed_announce)
        announce_thread.daemon = True
        announce_thread.start()
        
        print("\n‚è≥ En attente de messages...\n")
        
        try:
            while self.running:
                # Recevoir un paquet
                data, addr = self.sock.recvfrom(4096)
                
                # Parser le paquet CoAP
                packet = parse_coap_packet(data)
                
                if packet:
                    self.event_count += 1
                    timestamp = datetime.now().strftime("%H:%M:%S")

                    # Afficher message CoAP sauf pour ble-beacon (d√©j√† logu√© dans handle_ble_beacon)
                    if packet['uri_path'] != 'ble-beacon':
                        print(f"\nüì® [{timestamp}] Message CoAP #{self.event_count}")
                        print(f"   Source: {addr[0]}")
                        print(f"   URI: /{packet['uri_path']}")
                        print(f"   Code: {packet['code']}")

                    # Mettre √† jour le statut du node
                    if addr[0] not in self.node_status:
                        self.node_status[addr[0]] = {}
                    self.node_status[addr[0]]['last_seen'] = datetime.now()

                    # Traiter selon l'URI
                    if packet['uri_path'] == 'battery':
                        # Traiter le rapport batterie
                        message = ""
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                            print(f"   Payload: '{message}'")
                        else:
                            print(f"   Payload: (vide)")
                        self.handle_battery_report(addr[0], message)
                    elif packet['uri_path'] == 'button':
                        # Traiter l'√©v√©nement button m√™me sans payload
                        message = ""
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                            print(f"   Payload: '{message}'")
                        else:
                            print(f"   Payload: (vide)")
                        self.handle_button_event(addr[0], message)
                    elif packet['uri_path'] == 'server-id':
                        message = ""
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                            print(f"   Payload: '{message}'")
                        self.handle_server_id(addr[0], message)
                    elif packet['uri_path'] == 'ble-beacon':
                        message = ""
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                        self.handle_ble_beacon(addr[0], message)
                    else:
                        # Pour les autres URIs, afficher le payload s'il existe
                        if packet['payload']:
                            message = packet['payload'].decode('utf-8', errors='ignore')
                            print(f"   Payload: '{message}'")
                    
                    # Envoyer ACK si n√©cessaire
                    if packet['type'] == 0:  # CON (Confirmable)
                        response = create_coap_response(packet['message_id'])
                        self.sock.sendto(response, addr)
                        print("   ‚Üê ACK envoy√©")
                        
        except KeyboardInterrupt:
            print("\n\n‚úã Arr√™t du serveur")
        finally:
            self.running = False
            if self.sock:
                self.sock.close()
            if self.thingsboard.connected:
                self.thingsboard.disconnect()
            print(f"üìä Total √©v√©nements: {self.event_count}")
    
    def show_help(self):
        """Affiche l'aide des commandes"""
        print("\nüéÆ Commandes disponibles:")
        print("  help     - Afficher cette aide")
        print("  list     - Lister tous les nodes")
        print("  reload   - Recharger adresses.json")
        print("  announce - Annoncer le serveur aux nodes")
        print("  flash    - Faire clignoter tous les nodes (1 fois)")
        print("  path [vitesse_ms] - Chemin lumineux (d√©faut: 1000ms)")
        print("    Exemple: path 500 pour 500ms par node")
        print("  blink <node|all> <led> [p√©riode_ms] [duty_%] - Faire clignoter une LED")
        print("    LEDs: red, light, all")
        print("    Exemples: blink d2C red          (1000ms, 50%)")
        print("              blink all red 500 25   (500ms, 25%)")
        print("              blink d3D light 2000 75 (2000ms, 75%)")
        print("  blink stop [node|all] - Arr√™ter le clignotement")
        print("  led <node> <cmd> - Envoyer commande LED (contr√¥le direct)")
        print("    Commandes: red:on/off, light:on/off, all:on/off")
        print("  light on/off - Allumer/√©teindre toutes les LED externes")
        print("  battery  - Afficher l'√©tat des batteries")
        print("  beacon   - Afficher les beacons BLE d√©tect√©s")
        print("  quality  - Statistiques de qualit√© des badges (s√©quence po1-po0)")
        print("  tb       - √âtat de la connexion ThingsBoard")
        print("  tb refresh - Rafra√Æchir le cache des assets ThingsBoard")
        print("  tb reconnect - Forcer la reconnexion √† ThingsBoard")
        print("  tb devices - Afficher les devices et leurs positions loc_code")
        print("  demo     - Mode d√©mo (announce + flash toutes les 10s)")
        print("  stop     - Arr√™ter le mode d√©mo")
        print("  quit     - Quitter")
        print()
    
    def command_loop(self):
        """Boucle de commandes interactives"""
        time.sleep(1)  # Attendre que le serveur d√©marre
        
        self.show_help()
        
        while self.running:
            try:
                cmd = input("coap> ").strip()
                
                if cmd == "quit":
                    self.running = False
                    self.demo_mode = False
                    break
                elif cmd == "help":
                    self.show_help()
                elif cmd == "list":
                    print("\nüìã Nodes enregistr√©s:")
                    for name, node_data in self.registry.nodes.items():
                        if isinstance(node_data, dict):
                            addr = node_data.get('address', '')
                            ordre = node_data.get('ordre', 0)
                            ordre_str = f" (ordre: {ordre})" if ordre > 0 else " (pas dans le chemin)"
                            print(f"  {name}: {addr}{ordre_str}")
                        else:
                            # Ancien format
                            print(f"  {name}: {node_data}")
                    print()
                elif cmd == "reload":
                    self.registry.load()
                elif cmd == "announce":
                    self.announce_server()
                elif cmd == "battery":
                    # Afficher l'√©tat des batteries
                    print("\nüîã √âtat des batteries:")
                    if not self.battery_status:
                        print("   Aucun rapport de batterie re√ßu")
                    else:
                        for node_name, data in self.battery_status.items():
                            if data['current']:
                                current = data['current']
                                age = (datetime.now() - current['timestamp']).total_seconds()
                                status_icon = "üîã" if current['percentage'] > 20 else "ü™´"
                                print(f"   {status_icon} {node_name}: {current['voltage']:.2f}V ({current['percentage']}%) - il y a {int(age)}s")
                                
                                # Afficher l'historique r√©cent si demand√©
                                if len(data['history']) > 1:
                                    voltages = [h['voltage'] for h in data['history']]
                                    avg_voltage = sum(voltages) / len(voltages)
                                    trend = "üìà" if voltages[-1] > voltages[0] else "üìâ" if voltages[-1] < voltages[0] else "‚û°Ô∏è"
                                    print(f"      Moyenne: {avg_voltage:.2f}V {trend}")
                    print()
                elif cmd == "beacon":
                    # Afficher les d√©tections BLE beacon
                    print("\nüì° D√©tections BLE Beacon:")
                    if not self.ble_detections:
                        print("   Aucun beacon d√©tect√©")
                    else:
                        for code, data in self.ble_detections.items():
                            age = (datetime.now() - data['timestamp']).total_seconds()
                            print(f"   {code}: {data['addr']} (RSSI: {data['rssi']} dBm)")
                            print(f"      Node: {data['node']} - Il y a {int(age)}s")
                    print()

                elif cmd == "quality":
                    # Afficher les statistiques de qualit√© des badges
                    print("\nüìä Badge Quality Report\n")
                    if not self.badge_trackers:
                        print("   Aucun badge track√©")
                    else:
                        for addr, tracker in self.badge_trackers.items():
                            stats = tracker.get_stats()
                            print(f"Badge {addr[-8:]}:")
                            print(f"  Runtime         : {int(stats['runtime_sec'])}s")
                            print(f"  Frames expected : {stats['total_expected']}")
                            print(f"  Frames received : {stats['received']}")
                            print(f"  Frames missed   : {stats['missed']}")
                            print(f"  Success rate    : {stats['success_rate']:.1f}%")
                            print(f"  Last code       : {stats['last_code']}")
                            print()

                elif cmd == "flash":
                    # Faire clignoter toutes les LEDs externes
                    print("üí° Flash toutes les LED externes...")
                    addresses = self.registry.get_all_addresses()
                    for addr in addresses:
                        self.send_coap_post(addr, "led", "light:on")
                    time.sleep(1)
                    for addr in addresses:
                        self.send_coap_post(addr, "led", "light:off")
                elif cmd.startswith("path") or cmd.startswith("chemin"):
                    # Chemin lumineux avec vitesse param√©trable
                    parts = cmd.split()
                    speed_ms = 1000  # Vitesse par d√©faut
                    
                    # Parser la vitesse si fournie
                    if len(parts) >= 2:
                        try:
                            speed_ms = int(parts[1])
                            if speed_ms < 100:
                                speed_ms = 100  # Minimum 100ms
                            elif speed_ms > 10000:
                                speed_ms = 10000  # Maximum 10s
                        except ValueError:
                            print("‚ö†Ô∏è Vitesse invalide, utilisation de 1000ms par d√©faut")
                    
                    print(f"üåà Chemin lumineux d√©marr√© (vitesse: {speed_ms}ms)")
                    print("   Appuyez sur Ctrl+C pour arr√™ter...")
                    
                    # R√©cup√©rer les nodes tri√©s par ordre
                    sorted_nodes = self.registry.get_nodes_sorted_by_order()
                    
                    if not sorted_nodes:
                        print("‚ùå Aucun node avec un ordre d√©fini (ordre > 0)")
                    else:
                        print(f"   Nodes dans l'ordre: {[n['name'] for n in sorted_nodes]}")
                        
                        try:
                            while True:
                                for node in sorted_nodes:
                                    # Allumer le node actuel
                                    self.send_coap_post(node['address'], "led", "light:on")
                                    time.sleep(speed_ms / 1000.0)
                                    # √âteindre le node actuel
                                    self.send_coap_post(node['address'], "led", "light:off")
                                    time.sleep(50 / 1000.0)  # Petite pause entre nodes
                        except KeyboardInterrupt:
                            print("\n‚èπÔ∏è Chemin lumineux arr√™t√©")
                            # √âteindre toutes les LEDs
                            for node in sorted_nodes:
                                self.send_coap_post(node['address'], "led", "light:off")
                elif cmd.startswith("blink"):
                    # Commande blink avec param√®tres optionnels
                    parts = cmd.split()
                    
                    # V√©rifier si c'est une commande stop
                    if len(parts) >= 2 and parts[1] == "stop":
                        # blink stop [node|all]
                        target = parts[2] if len(parts) >= 3 else "all"
                        
                        if target == "all":
                            print("‚èπÔ∏è Arr√™t du clignotement sur tous les nodes...")
                            addresses = self.registry.get_all_addresses()
                            for addr in addresses:
                                self.send_coap_post(addr, "blink", "stop")
                        else:
                            # Arr√™ter sur un node sp√©cifique
                            if target in self.registry.nodes:
                                node_data = self.registry.nodes[target]
                                if isinstance(node_data, dict):
                                    addr = node_data.get('address')
                                else:
                                    addr = node_data
                                
                                if addr:
                                    print(f"‚èπÔ∏è Arr√™t du clignotement sur {target}...")
                                    self.send_coap_post(addr, "blink", "stop")
                                else:
                                    print(f"‚ùå Adresse manquante pour '{target}'")
                            else:
                                print(f"‚ùå Node '{target}' non trouv√©")
                    else:
                        # Commande blink normale
                        if len(parts) < 3:
                            print("‚ùå Usage: blink <node|all> <led> [p√©riode_ms] [duty_%]")
                            print("         blink stop [node|all]")
                        else:
                            target = parts[1]  # node ou "all"
                            led_type = parts[2]  # red, light, all
                            period_ms = parts[3] if len(parts) >= 4 else "1000"
                            duty_cycle = parts[4] if len(parts) >= 5 else "50"
                            
                            # Construire le payload pour la ressource /blink
                            payload = f"{led_type}:{period_ms}:{duty_cycle}"
                            
                            if target == "all":
                                print(f"üí´ Clignotement {led_type} sur tous les nodes ({period_ms}ms, {duty_cycle}%)...")
                                addresses = self.registry.get_all_addresses()
                                for addr in addresses:
                                    self.send_coap_post(addr, "blink", payload)
                            else:
                                # Envoyer √† un node sp√©cifique
                                if target in self.registry.nodes:
                                    node_data = self.registry.nodes[target]
                                    if isinstance(node_data, dict):
                                        addr = node_data.get('address')
                                    else:
                                        addr = node_data
                                    
                                    if addr:
                                        print(f"üí´ Clignotement {led_type} sur {target} ({period_ms}ms, {duty_cycle}%)...")
                                        self.send_coap_post(addr, "blink", payload)
                                    else:
                                        print(f"‚ùå Adresse manquante pour '{target}'")
                                else:
                                    print(f"‚ùå Node '{target}' non trouv√©")
                elif cmd == "demo":
                    if not self.demo_mode:
                        self.demo_mode = True
                        # Lancer le thread de d√©mo
                        demo_thread = threading.Thread(target=self.demo_loop)
                        demo_thread.daemon = True
                        demo_thread.start()
                    else:
                        print("‚ö†Ô∏è Mode d√©mo d√©j√† actif. Utilisez 'stop' ou Ctrl+C pour l'arr√™ter.")
                elif cmd == "stop":
                    if self.demo_mode:
                        print("‚èπÔ∏è Arr√™t du mode d√©mo...")
                        self.demo_mode = False
                        time.sleep(1)  # Laisser le temps au thread de s'arr√™ter
                    else:
                        print("‚ÑπÔ∏è Le mode d√©mo n'est pas actif")
                elif cmd == "tb":
                    # √âtat ThingsBoard
                    if self.thingsboard.connected:
                        print(f"‚úÖ ThingsBoard: Connect√© √† {TB_CONFIG['url']}")
                        print(f"   User: {TB_CONFIG['username']}")
                        
                        # Afficher l'√¢ge du token
                        token_age = int(time.time() - self.thingsboard.token_timestamp)
                        token_remaining = max(0, self.thingsboard.token_lifetime - token_age)
                        print(f"   Token: valide encore {token_remaining}s ({token_age}s d'√¢ge)")
                        
                        print(f"   Assets en cache: {len(self.thingsboard.asset_cache)}")
                        if self.thingsboard.asset_cache:
                            print("   Assets:")
                            for name in sorted(self.thingsboard.asset_cache.keys()):
                                print(f"     - {name}")
                        
                        print(f"\n   Devices en cache: {len(self.thingsboard.device_cache)}")
                        if self.thingsboard.device_cache:
                            print("   Devices avec loc_code:")
                            for name in sorted(self.thingsboard.device_cache.keys()):
                                loc_info = self.thingsboard.device_loc_code.get(name, {})
                                loc_value = loc_info.get('value', 'N/A')
                                if loc_value and loc_value != 'N/A':
                                    ts = loc_info.get('timestamp')
                                    if ts:
                                        age = int((time.time() * 1000 - ts) / 1000)
                                        print(f"     üìç {name}: {loc_value} (il y a {age}s)")
                                    else:
                                        print(f"     üìç {name}: {loc_value}")
                                else:
                                    print(f"     ‚óã {name}: (pas de position)")
                    else:
                        print("‚ùå ThingsBoard: Non connect√©")
                elif cmd == "tb refresh":
                    # Rafra√Æchir le cache des assets
                    if self.thingsboard.connected:
                        self.thingsboard.refresh_asset_cache()
                    else:
                        print("‚ùå ThingsBoard non connect√©")
                elif cmd == "tb devices":
                    # Afficher l'√©tat des devices
                    if self.thingsboard.connected:
                        print("\nüì± Devices ThingsBoard:")
                        if not self.thingsboard.device_cache:
                            print("   Aucun device trouv√©")
                        else:
                            print(f"   Total: {len(self.thingsboard.device_cache)} devices")
                            print("\n   üìç Positions LOC_CODE:")
                            print("   " + "="*50)
                            
                            # Trier par nom
                            for name in sorted(self.thingsboard.device_cache.keys()):
                                loc_info = self.thingsboard.device_loc_code.get(name, {})
                                loc_value = loc_info.get('value')
                                
                                if loc_value:
                                    ts = loc_info.get('timestamp')
                                    if ts:
                                        age = int((time.time() * 1000 - ts) / 1000)
                                        if age < 60:
                                            age_str = f"{age}s"
                                        elif age < 3600:
                                            age_str = f"{age//60}min"
                                        else:
                                            age_str = f"{age//3600}h"
                                        
                                        # Ic√¥ne selon l'√¢ge
                                        if age < 10:
                                            icon = "üü¢"  # Tr√®s r√©cent
                                        elif age < 60:
                                            icon = "üü°"  # R√©cent
                                        else:
                                            icon = "üî¥"  # Ancien
                                        
                                        print(f"   {icon} {name:20} : {loc_value:15} (il y a {age_str})")
                                    else:
                                        print(f"   üîµ {name:20} : {loc_value:15}")
                                else:
                                    print(f"   ‚ö™ {name:20} : {'Pas de position':15}")
                            
                            # Statistiques
                            with_position = sum(1 for loc in self.thingsboard.device_loc_code.values() if loc.get('value'))
                            print("\n   üìä Statistiques:")
                            print(f"      ‚Ä¢ Devices avec position: {with_position}/{len(self.thingsboard.device_cache)}")
                            
                            # Afficher les devices DALKIA sp√©cifiquement
                            dalkia_devices = [name for name in self.thingsboard.device_cache.keys() if 'DALKIA' in name.upper()]
                            if dalkia_devices:
                                print(f"\n   üè∑Ô∏è Badges DALKIA d√©tect√©s: {len(dalkia_devices)}")
                                for name in sorted(dalkia_devices):
                                    loc_info = self.thingsboard.device_loc_code.get(name, {})
                                    loc_value = loc_info.get('value', 'N/A')
                                    print(f"      ‚Ä¢ {name}: {loc_value}")
                    else:
                        print("‚ùå ThingsBoard non connect√©")
                elif cmd == "tb reconnect":
                    # Forcer la reconnexion
                    print("üîÑ Reconnexion √† ThingsBoard...")
                    if self.thingsboard.reconnect():
                        print("‚úÖ Reconnexion r√©ussie")
                    else:
                        print("‚ùå √âchec de la reconnexion")
                elif cmd.startswith("light "):
                    # Commande light pour tous les nodes
                    parts = cmd.split()
                    if len(parts) >= 2:
                        action = parts[1]
                        if action in ["on", "off"]:
                            print(f"üí° Envoi commande light:{action} √† tous les nodes...")
                            addresses = self.registry.get_all_addresses()
                            for addr in addresses:
                                self.send_coap_post(addr, "led", f"light:{action}")
                        else:
                            print("‚ùå Usage: light on/off")
                elif cmd.startswith("led "):
                    parts = cmd.split()
                    if len(parts) >= 3:
                        node_name = parts[1]
                        led_cmd = parts[2]
                        if node_name in self.registry.nodes:
                            node_data = self.registry.nodes[node_name]
                            # G√©rer le nouveau format avec dictionnaire
                            if isinstance(node_data, dict):
                                addr = node_data.get('address')
                            else:
                                # Ancien format (compatibilit√©)
                                addr = node_data
                            
                            if addr:
                                self.send_coap_post(addr, "led", led_cmd)
                            else:
                                print(f"‚ùå Adresse manquante pour '{node_name}'")
                        else:
                            print(f"‚ùå Node '{node_name}' non trouv√©")
                else:
                    if cmd:
                        print("‚ùå Commande inconnue")
                        
            except EOFError:
                break
            except KeyboardInterrupt:
                if self.demo_mode:
                    print("\n\n‚èπÔ∏è Arr√™t du mode d√©mo...")
                    self.demo_mode = False
                    time.sleep(1)  # Laisser le temps au thread de s'arr√™ter
                    print()  # Nouvelle ligne pour le prompt
                else:
                    print("\n")
                    break
            except Exception as e:
                print(f"Erreur: {e}")

# Instances globales pour les routes Flask
coap_server = None

# Module-level dict that persists across reimports (by Flask workers)
# This solves the "coap_server is None" issue when workers reimport the module
_server_instances = {}

def get_coap_server():
    """Retourne l'instance du serveur CoAP avec lazy initialization

    Cr√©e l'instance au premier appel, puis la r√©utilise.
    Cela r√©sout le probl√®me de module import√© plusieurs fois par les workers Flask.
    """
    if 'coap_server' not in _server_instances:
        # Lazy initialization: cr√©er l'instance seulement si elle n'existe pas encore
        print("üîß [get_coap_server] Lazy initialization - cr√©ation de CoAPServer")
        _server_instances['coap_server'] = CoAPServer()
        print(f"‚úÖ [get_coap_server] CoAPServer cr√©√©: {_server_instances['coap_server']} (id={id(_server_instances['coap_server'])})")

    return _server_instances.get('coap_server')
network_scanner = None
network_topology_data = None
topology_lock = threading.Lock()

# Border Router Manager (instance globale)
border_router_manager = BorderRouterManager(heartbeat_timeout=BR_HEARTBEAT_TIMEOUT)

# Native WebSocket Handler for Border Routers
from lib.native_websocket_handler import NativeWebSocketHandler
native_ws_handler = NativeWebSocketHandler(
    border_router_manager=border_router_manager,
    br_auth_enabled=BR_AUTH_ENABLED
)

# Fonction pour rafra√Æchir la topologie en arri√®re-plan
def refresh_topology_background():
    """Rafra√Æchit la topologie du r√©seau en arri√®re-plan"""
    global network_topology_data

    try:
        # Cr√©er une nouvelle boucle d'√©v√©nements pour ce thread
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        # Charger les noms depuis adresses.json
        address_names = {}
        try:
            with open(ADDRESSES_FILE, 'r') as f:
                data = json.load(f)
                nodes = data.get('nodes', {})
                for node_name, node_data in nodes.items():
                    if isinstance(node_data, dict):
                        addr = node_data.get('address')
                        if addr:
                            address_names[addr] = node_name
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur chargement noms depuis adresses.json: {e}")

        # Cr√©er le scanner avec les adresses connues et le mapping des noms
        known_addresses = coap_server.registry.get_all_addresses() if coap_server else []
        scanner = OpenThreadScanner(known_addresses=known_addresses, address_names=address_names)

        # Scanner le r√©seau
        loop.run_until_complete(scanner.build_topology())

        # Calculer les distances en sauts depuis le leader
        scanner.topology.calculate_hop_distances()

        # Convertir en JSON
        with topology_lock:
            network_topology_data = json.loads(scanner.topology.to_json())

        # Mettre √† jour le mapping nom ‚Üí RLOC16 pour la triangulation
        if coap_server:
            coap_server.name_to_rloc16.clear()
            for node in scanner.topology.nodes.values():
                if node.name and node.rloc16:
                    coap_server.name_to_rloc16[node.name] = node.rloc16
            print(f"üìç Mapping nom‚ÜíRLOC16 mis √† jour: {len(coap_server.name_to_rloc16)} entr√©es")

        # √âmettre via WebSocket
        socketio.emit('topology_update', network_topology_data)

        # Afficher les n≈ìuds d√©couverts avec leur nom
        node_count = len(scanner.topology.nodes)
        nodes_with_names = [n for n in scanner.topology.nodes.values() if n.name]
        print(f"‚úÖ Topologie rafra√Æchie: {node_count} n≈ìuds ({len(nodes_with_names)} nomm√©s)")
        for node in scanner.topology.nodes.values():
            node_label = f"{node.name} ({node.rloc16})" if node.name else node.rloc16
            print(f"   ‚Ä¢ {node_label} - {node.role}")

        loop.close()

    except Exception as e:
        print(f"‚ùå Erreur rafra√Æchissement topologie: {e}")
        import traceback
        traceback.print_exc()

def scan_all_nodes_via_brs():
    """
    Orchestrateur central du scan r√©seau via Border Routers (d√©couverte dynamique)

    Cette fonction coordonne le scan de tous les nodes du r√©seau en:
    1. R√©cup√©rant la liste des Border Routers connect√©s
    2. Envoyant une commande 'scan_all_nodes' √† CHAQUE BR
    3. Chaque BR d√©couvre automatiquement les nodes dans son r√©seau Thread
    4. Les r√©sultats sont re√ßus de mani√®re asynchrone via WebSocket

    Architecture de d√©couverte dynamique:
    - Python ne connait PAS la liste des nodes √† l'avance
    - Python ne sait PAS quel node est derri√®re quel BR
    - Chaque BR d√©couvre ses propres nodes via OpenThread APIs
    - Chaque BR scanne ses nodes et renvoie les r√©sultats

    Les r√©sultats sont re√ßus de mani√®re asynchrone via WebSocket et
    √©mis aux clients web via Socket.IO (√©v√©nement 'scan_node_result')

    Returns:
        dict: Statistiques du scan (broadcast_sent, br_count)
    """
    try:
        # 1. R√©cup√©rer tous les Border Routers connect√©s
        active_brs = native_ws_handler.get_active_br_ids()

        if not active_brs:
            print("‚ö†Ô∏è No Border Routers connected - cannot scan network")
            return {
                'broadcast_sent': False,
                'br_count': 0,
                'error': 'No Border Routers connected'
            }

        print(f"üîç Starting dynamic network scan: broadcasting to {len(active_brs)} Border Router(s)")

        # 2. Envoyer commande scan_all_nodes √† TOUS les BRs
        commands_sent = 0
        for br_id in active_brs:
            request_id = str(uuid.uuid4())
            success = native_ws_handler.send_scan_all_command(
                br_id=br_id,
                request_id=request_id
            )

            if success:
                commands_sent += 1
                print(f"‚úÖ scan_all_nodes broadcast to {br_id} (request_id: {request_id})")
            else:
                print(f"‚ùå Failed to send scan_all_nodes to {br_id}")

        print(f"üìä Dynamic scan broadcast complete: {commands_sent}/{len(active_brs)} BRs notified")
        return {
            'broadcast_sent': True,
            'br_count': len(active_brs),
            'commands_sent': commands_sent
        }

    except Exception as e:
        print(f"‚ùå Error in scan_all_nodes_via_brs: {e}")
        import traceback
        traceback.print_exc()
        return {
            'broadcast_sent': False,
            'br_count': 0,
            'error': str(e)
        }

# Routes Flask
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/beacons')
def beacons_page():
    """Page de suivi des beacons BLE d√©tect√©s"""
    return render_template('beacons.html')

@app.route('/ble_debug')
def ble_debug_page():
    """Page de debug BLE temps r√©el"""
    return render_template('ble_debug.html')

@app.route('/test_socket')
def test_socket_page():
    """Page de test Socket.IO basique"""
    return render_template('test_socket.html')

@app.route('/devices')
def devices_page():
    """Page de suivi des devices et leurs positions"""
    return render_template('devices.html')

@app.route('/network-map')
def network_map_page():
    """Page de cartographie du r√©seau OpenThread"""
    return render_template('network_map.html')

@app.route('/audio-control')
def audio_control_page():
    """Page de contr√¥le audio des nodes PTI (ancienne interface)"""
    return render_template('audio_control.html')

@app.route('/audio-library')
def audio_library_page():
    """Interface web pour la biblioth√®que audio"""
    return render_template('audio_library.html')

@app.route('/api/health')
def health_check():
    """Endpoint de health check pour Docker et monitoring"""
    return jsonify({
        'status': 'healthy',
        'timestamp': time.time(),
        'service': 'luxnavix-coap-server',
        'version': '1.0'
    }), 200

@app.route('/api/topology')
def get_topology():
    """Retourne la topologie actuelle du r√©seau depuis Network Diagnostic"""
    # Get topology from NetworkTopologyAggregator (Network Diagnostic events)
    topology = native_ws_handler.get_network_topology()

    # Transform to legacy format for frontend compatibility
    # Convert NetworkTopologyAggregator format to old topology format
    nodes = []
    for node in topology.get('nodes', []):
        # Get first RLOC16 and ML-EID
        rloc16 = node['rloc16s'][0] if node['rloc16s'] else 'unknown'
        ml_eid = node['mleids'][0] if node['mleids'] else None

        # Get business name or use ext_addr short form
        name = node.get('business_name', f"node_{node['ext_addr'][:8]}")

        # Determine role (use first role or 'unknown')
        role = node['roles'][0] if node['roles'] else 'unknown'

        nodes.append({
            'name': name,
            'address': ml_eid,
            'rloc16': rloc16,
            'role': role,
            'ext_addr': node['ext_addr'],
            'partition_id': node['partition_id'],
            'br_ids': node['br_ids'],
            'is_br': node.get('is_br', False),
            'last_seen': node['last_seen']
        })

    # Calculate statistics
    stats = topology.get('stats', {})
    total_nodes = stats.get('total_nodes', 0)
    leaders = sum(1 for n in nodes if 'leader' in n.get('role', ''))
    routers = sum(1 for n in nodes if 'router' in n.get('role', ''))
    children = sum(1 for n in nodes if 'child' in n.get('role', ''))

    return jsonify({
        'network_name': 'Thread Network',
        'partition_id': nodes[0]['partition_id'] if nodes else None,
        'last_update': stats.get('timestamp'),
        'nodes': nodes,
        'router_links': topology.get('router_links', []),
        'child_links': topology.get('child_links', []),
        'statistics': {
            'total_nodes': total_nodes,
            'leaders': leaders,
            'routers': routers,
            'children': children,
            'total_router_links': stats.get('total_router_links', 0),
            'total_child_links': stats.get('total_child_links', 0)
        }
    })

@app.route('/api/refresh_topology', methods=['POST'])
def refresh_topology():
    """Lance un scan du r√©seau et rafra√Æchit la topologie"""
    # Lancer dans un thread pour ne pas bloquer
    thread = threading.Thread(target=refresh_topology_background)
    thread.daemon = True
    thread.start()
    return jsonify({'status': 'started'})

@app.route('/api/br/status')
def get_br_status():
    """
    Retourne le statut de tous les Border Routers connect√©s

    Returns:
        JSON avec les statistiques et le statut de chaque BR
    """
    if not USE_WEBSOCKET_BR:
        return jsonify({
            'websocket_mode': False,
            'message': 'Border Router WebSocket mode is disabled'
        })

    try:
        # R√©cup√©rer les statistiques globales
        statistics = border_router_manager.get_statistics()

        # R√©cup√©rer le statut de tous les BRs
        border_routers = border_router_manager.get_all_brs_status()

        return jsonify({
            'websocket_mode': True,
            'statistics': statistics,
            'border_routers': border_routers,
            'timestamp': datetime.now().isoformat()
        })

    except Exception as e:
        print(f"Erreur r√©cup√©ration statut BR: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/border_routers')
def get_border_routers():
    """
    Alias pour /api/br/status - compatibilit√© avec network-map.html

    Returns:
        JSON avec les statistiques et le statut de chaque BR
    """
    return get_br_status()

@app.route('/api/trigger_scan', methods=['POST'])
def trigger_scan():
    """
    D√©clenche un scan complet du r√©seau via les Border Routers

    Cette route lance un scan orchestr√© de tous les nodes du r√©seau.
    Les r√©sultats sont envoy√©s de mani√®re asynchrone via Socket.IO
    (√©v√©nement 'scan_node_result') au fur et √† mesure que les nodes
    r√©pondent.

    Returns:
        JSON avec le statut du scan et les statistiques
    """
    try:
        print("üîç API: Triggering network scan via BRs")

        # Lancer le scan orchestr√© (d√©couverte dynamique)
        stats = scan_all_nodes_via_brs()

        # Retourner les statistiques (nouveau format)
        if stats.get('broadcast_sent', False):
            br_count = stats.get('br_count', 0)
            commands_sent = stats.get('commands_sent', 0)
            return jsonify({
                'success': True,
                'message': f"Network scan broadcasted to {br_count} Border Router(s)",
                'statistics': stats
            })
        else:
            return jsonify({
                'success': False,
                'message': stats.get('error', 'No Border Routers connected'),
                'statistics': stats
            }), 500

    except Exception as e:
        print(f"‚ùå Error triggering scan: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/nodes')
def get_nodes():
    """Retourne TOUS les nodes de adresses.json, avec nodes actifs en premier"""
    global coap_server
    import json

    # 1Ô∏è‚É£ Charger tous les nodes depuis adresses.json
    try:
        with open('config/adresses.json', 'r', encoding='utf-8') as f:
            config = json.load(f)
        all_configured_nodes = config.get('nodes', {})
    except Exception as e:
        print(f"‚ùå Error loading adresses.json: {e}")
        all_configured_nodes = {}

    # 2Ô∏è‚É£ Obtenir les nodes actifs (last_seen < 60s)
    active_nodes_list = native_ws_handler.get_active_nodes(timeout_seconds=60)

    # 3Ô∏è‚É£ Cr√©er un dictionnaire des nodes actifs pour lookup rapide
    active_nodes_dict = {node['name']: node for node in active_nodes_list}

    print(f"üìã /api/nodes: {len(all_configured_nodes)} configured nodes, {len(active_nodes_dict)} active")

    # 4Ô∏è‚É£ Construire la liste compl√®te
    nodes_data = []

    for name, node_config in all_configured_nodes.items():
        ipv6 = node_config.get('address')
        ordre = node_config.get('ordre', 0)

        # V√©rifier si le node est actif
        if name in active_nodes_dict:
            # Node ACTIF - inclure toutes les donn√©es temps r√©el
            active_info = active_nodes_dict[name]

            print(f"   üü¢ {name} @ {ipv6} (ONLINE via {active_info['br_id']}, seen {active_info['seconds_ago']}s ago)")

            # R√©cup√©rer l'√©tat de la batterie
            battery = None
            if coap_server and name in coap_server.battery_status:
                battery_data = coap_server.battery_status[name]
                # Supporter les deux formats: {'current': {...}} et {'voltage': ..., 'percentage': ...}
                current = battery_data.get('current') or battery_data
                if current and isinstance(current, dict):
                    timestamp = current.get('timestamp')
                    battery = {
                        'voltage': current.get('voltage', 0),
                        'percentage': current.get('percentage', 0),
                        'timestamp': timestamp.isoformat() if hasattr(timestamp, 'isoformat') else timestamp
                    }

            # R√©cup√©rer l'√©tat des LEDs
            led_states = coap_server.led_states.get(active_info['ipv6'], {}) if coap_server else {}

            # R√©cup√©rer l'√©tat du LED driver
            led_driver = coap_server.led_driver_states.get(name, {}) if coap_server else {}
            led_driver_intensity = led_driver.get('intensity', 0)

            nodes_data.append({
                'name': name,
                'address': ipv6,
                'br_id': active_info['br_id'],
                'last_seen': active_info['last_seen'],
                'seconds_ago': active_info['seconds_ago'],
                'ordre': ordre,
                'battery': battery,
                'leds': {
                    'red': led_states.get('red', False),
                    'light': led_states.get('light', False)
                },
                'led_driver': {
                    'intensity': led_driver_intensity,
                    'state': led_driver_intensity > 0
                },
                'online': True
            })
        else:
            # Node INACTIF - pas de donn√©es temps r√©el
            print(f"   üî¥ {name} @ {ipv6} (OFFLINE)")

            nodes_data.append({
                'name': name,
                'address': ipv6,
                'br_id': None,
                'last_seen': None,
                'seconds_ago': None,
                'ordre': ordre,
                'battery': None,
                'leds': {
                    'red': False,
                    'light': False
                },
                'led_driver': {
                    'intensity': 0,
                    'state': False
                },
                'online': False
            })

    # 5Ô∏è‚É£ Trier : nodes connect√©s en premier, puis par nom
    nodes_data.sort(key=lambda n: (not n['online'], n['name']))

    print(f"‚úÖ /api/nodes: Returning {len(nodes_data)} total nodes ({len(active_nodes_dict)} online, {len(nodes_data) - len(active_nodes_dict)} offline)")
    return jsonify(nodes_data)

@app.route('/api/devices')
def get_devices():
    """Retourne la liste des devices ThingsBoard avec leurs positions loc_code"""
    devices_data = []
    
    if coap_server.thingsboard.connected:
        for device_name, device_id in coap_server.thingsboard.device_cache.items():
            loc_info = coap_server.thingsboard.device_loc_code.get(device_name, {})
            loc_value = loc_info.get('value')
            loc_timestamp = loc_info.get('timestamp')
            
            # Calculer l'√¢ge de la derni√®re position
            age_seconds = None
            if loc_timestamp:
                age_seconds = int((time.time() * 1000 - loc_timestamp) / 1000)
            
            devices_data.append({
                'name': device_name,
                'id': device_id,
                'loc_code': loc_value,
                'loc_timestamp': loc_timestamp,
                'age_seconds': age_seconds,
                'is_dalkia': 'DALKIA' in device_name.upper()
            })
    
    # Trier par nom
    devices_data.sort(key=lambda x: x['name'])
    
    return jsonify(devices_data)

@app.route('/api/command', methods=['POST'])
def send_command():
    """Envoie une commande √† un ou plusieurs nodes"""
    data = request.json
    command_type = data.get('type')
    target = data.get('target')  # 'all' ou nom du node
    
    if command_type == 'led':
        led = data.get('led')  # red, light, all
        action = data.get('action')  # on, off

        if target == 'all':
            # Envoyer √† tous les nodes via WebSocket BR
            for node_name in coap_server.registry.nodes.keys():
                success = native_ws_handler.send_command_to_node(
                    node_name,
                    'led',
                    f"{led}:{action}"
                )

                if success:
                    node_data = coap_server.registry.nodes[node_name]
                    addr = node_data.get('address') if isinstance(node_data, dict) else node_data

                    # Mettre √† jour l'√©tat local
                    if addr not in coap_server.led_states:
                        coap_server.led_states[addr] = {}
                    if led == 'all':
                        coap_server.led_states[addr]['red'] = (action == 'on')
                        coap_server.led_states[addr]['light'] = (action == 'on')
                    else:
                        coap_server.led_states[addr][led] = (action == 'on')
        else:
            # Envoyer √† un node sp√©cifique via WebSocket BR
            if target in coap_server.registry.nodes:
                success = native_ws_handler.send_command_to_node(
                    target,
                    'led',
                    f"{led}:{action}"
                )

                if success:
                    node_data = coap_server.registry.nodes[target]
                    addr = node_data.get('address') if isinstance(node_data, dict) else node_data

                    if addr:
                        # Mettre √† jour l'√©tat local
                        if addr not in coap_server.led_states:
                            coap_server.led_states[addr] = {}
                        if led == 'all':
                            coap_server.led_states[addr]['red'] = (action == 'on')
                            coap_server.led_states[addr]['light'] = (action == 'on')
                        else:
                            coap_server.led_states[addr][led] = (action == 'on')

                        # √âmettre la mise √† jour via WebSocket
                        socketio.emit('led_update', {
                            'node': target,
                            'led': led,
                            'state': action == 'on'
                        })

    elif command_type == 'led_driver':
        # Format: {"type": "led_driver", "target": "n01", "action": "on|off|set", "intensity": 50}
        action = data.get('action')  # "on", "off", "set"
        intensity = data.get('intensity', 50)  # 10-100%

        # Valider intensit√©
        if intensity < 10:
            intensity = 10
        elif intensity > 100:
            intensity = 100

        # Construire payload CoAP
        if action == 'off':
            payload = "intensity:0"
        else:
            payload = f"intensity:{intensity}"

        if target == 'all':
            # Envoyer √† tous les nodes via WebSocket BR
            for node_name in coap_server.registry.nodes.keys():
                success = native_ws_handler.send_command_to_node(
                    node_name,
                    'led/driver',
                    payload
                )

                if success:
                    # Mettre √† jour √©tat local
                    if node_name not in coap_server.led_driver_states:
                        coap_server.led_driver_states[node_name] = {}
                    coap_server.led_driver_states[node_name]['intensity'] = intensity if action != 'off' else 0
        else:
            # Envoyer √† un node sp√©cifique via WebSocket BR
            if target in coap_server.registry.nodes:
                success = native_ws_handler.send_command_to_node(
                    target,
                    'led/driver',
                    payload
                )

                if success:
                    # Mettre √† jour √©tat local
                    if target not in coap_server.led_driver_states:
                        coap_server.led_driver_states[target] = {}
                    coap_server.led_driver_states[target]['intensity'] = intensity if action != 'off' else 0

                    # Notifier frontend via WebSocket
                    socketio.emit('led_driver_update', {
                        'node': target,
                        'intensity': intensity if action != 'off' else 0,
                        'state': action != 'off'
                    })
    
    elif command_type == 'tracking_mode':
        # Activer/d√©sactiver le mode suivi de position
        action = data.get('action')  # 'start' ou 'stop'
        
        if action == 'start':
            coap_server.tracking_mode = True
            coap_server.current_tracking_node = None
            print("üéØ Mode Suivi de Position ACTIV√â")
            
            # Allumer toutes les LEDs au d√©marrage
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "led", "light:on")
                if addr not in coap_server.led_states:
                    coap_server.led_states[addr] = {}
                coap_server.led_states[addr]['light'] = True
            
            # √âmettre l'√©v√©nement d'activation
            socketio.emit('tracking_mode_status', {
                'active': True,
                'timestamp': datetime.now().isoformat()
            })
            
        elif action == 'stop':
            coap_server.tracking_mode = False
            coap_server.current_tracking_node = None
            print("üõë Mode Suivi de Position D√âSACTIV√â")
            
            # √âteindre toutes les LEDs √† l'arr√™t
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "led", "light:off")
                coap_server.send_coap_post(addr, "blink_stop", "")
                if addr not in coap_server.led_states:
                    coap_server.led_states[addr] = {}
                coap_server.led_states[addr]['light'] = False
            
            # √âmettre l'√©v√©nement de d√©sactivation
            socketio.emit('tracking_mode_status', {
                'active': False,
                'timestamp': datetime.now().isoformat()
            })
    
    elif command_type == 'blink':
        led = data.get('led')
        period = data.get('period', 1000)
        duty = data.get('duty', 50)
        
        payload = f"{led}:{period}:{duty}"
        
        if target == 'all':
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "blink", payload)
        else:
            if target in coap_server.registry.nodes:
                node_data = coap_server.registry.nodes[target]
                if isinstance(node_data, dict):
                    addr = node_data.get('address')
                else:
                    addr = node_data
                if addr:
                    coap_server.send_coap_post(addr, "blink", payload)
    
    elif command_type == 'blink_stop':
        if target == 'all':
            addresses = coap_server.registry.get_all_addresses()
            for addr in addresses:
                coap_server.send_coap_post(addr, "blink", "stop")
        else:
            if target in coap_server.registry.nodes:
                node_data = coap_server.registry.nodes[target]
                if isinstance(node_data, dict):
                    addr = node_data.get('address')
                else:
                    addr = node_data
                if addr:
                    coap_server.send_coap_post(addr, "blink", "stop")
    
    elif command_type == 'announce':
        coap_server.announce_server(flash_yellow=data.get('flash', False))
    
    elif command_type == 'demo':
        if not coap_server.demo_mode:
            coap_server.demo_mode = True
            demo_thread = threading.Thread(target=coap_server.demo_loop)
            demo_thread.daemon = True
            demo_thread.start()
            socketio.emit('demo_status', {'active': True})
    
    elif command_type == 'demo_stop':
        coap_server.demo_mode = False
        socketio.emit('demo_status', {'active': False})
    
    elif command_type == 'path':
        speed = data.get('speed', 1000)
        # Impl√©menter le chemin lumineux dans un thread
        def run_path():
            sorted_nodes = coap_server.registry.get_nodes_sorted_by_order()
            if sorted_nodes:
                for _ in range(3):  # 3 cycles
                    for node in sorted_nodes:
                        coap_server.send_coap_post(node['address'], "led", "light:on")
                        time.sleep(speed / 1000.0)
                        coap_server.send_coap_post(node['address'], "led", "light:off")
                        time.sleep(0.05)
        
        path_thread = threading.Thread(target=run_path)
        path_thread.daemon = True
        path_thread.start()
    
    return jsonify({'status': 'success'})

@app.route('/api/events')
def get_events():
    """Retourne l'historique des √©v√©nements boutons"""
    return jsonify(list(coap_server.button_events))

@app.route('/api/audio_command', methods=['POST'])
def send_audio_command():
    """Envoie une commande audio CoAP aux nodes (asynchrone pour ne pas bloquer SocketIO)"""
    data = request.json
    node_target = data.get('node')  # 'all' ou nom du node
    command = data.get('command')   # 'play:X' ou 'stop'

    if not command:
        return jsonify({'success': False, 'error': 'Missing command'}), 400

    # Fonction interne pour envoi asynchrone (ne bloque pas le thread Flask/SocketIO)
    def send_audio_async():
        try:
            if node_target == 'all':
                # Envoyer √† tous les nodes
                addresses = coap_server.registry.get_all_addresses()
                for addr in addresses:
                    coap_server.send_coap_post(addr, "audio", command)
            else:
                # Envoyer √† un node sp√©cifique
                if node_target in coap_server.registry.nodes:
                    node_data = coap_server.registry.nodes[node_target]
                    if isinstance(node_data, dict):
                        addr = node_data.get('address')
                    else:
                        addr = node_data

                    if addr:
                        coap_server.send_coap_post(addr, "audio", command)
                    else:
                        print(f"‚ö†Ô∏è Audio command: Node '{node_target}' address not found")
                else:
                    print(f"‚ö†Ô∏è Audio command: Node '{node_target}' not found")
        except Exception as e:
            print(f"‚ùå Erreur envoi audio async: {e}")

    # Lancer dans un thread s√©par√© pour ne pas bloquer Flask/SocketIO
    # Cela permet √† socketio.emit('ble_frame') de fonctionner en temps r√©el
    audio_thread = threading.Thread(target=send_audio_async)
    audio_thread.daemon = True
    audio_thread.start()

    # Retourner IMM√âDIATEMENT sans attendre l'envoi CoAP
    # Le thread Flask est lib√©r√© ‚Üí SocketIO peut diffuser les trames BLE en temps r√©el
    return jsonify({
        'success': True,
        'status': 'sent',
        'command': command,
        'target': node_target
    })

@app.route('/api/battery_history/<node_name>')
def get_battery_history(node_name):
    """Retourne l'historique de batterie d'un node"""
    if node_name in coap_server.battery_status:
        history = coap_server.battery_status[node_name]['history']
        data = [{
            'timestamp': h['timestamp'].isoformat(),
            'voltage': h['voltage'],
            'percentage': h['percentage']
        } for h in history]
        return jsonify(data)
    return jsonify([])

@app.route('/api/ble_history')
def get_ble_history():
    """Retourne l'historique complet des d√©tections BLE"""
    # Retourner les 200 derni√®res d√©tections, tri√©es par timestamp d√©croissant
    history = sorted(coap_server.ble_history, key=lambda x: x['timestamp'], reverse=True)[:200]
    return jsonify(history)

@app.route('/api/badge_positions')
def get_badge_positions():
    """Retourne les positions actuelles de tous les badges"""
    positions = []
    now = datetime.now()

    for badge_addr, pos_data in coap_server.badge_positions.items():
        # Calculer l'√¢ge de la position
        age_seconds = (now - pos_data['timestamp']).total_seconds()

        # Ne retourner que les positions r√©centes (< 10 secondes)
        if age_seconds < 10:
            # R√©cup√©rer le dernier code connu
            badge_detection = coap_server.ble_detections.get(badge_addr, {})
            code = badge_detection.get('code', 'unknown')

            positions.append({
                'badge_addr': badge_addr,
                'code': code,
                'x': pos_data['x'],
                'y': pos_data['y'],
                'confidence': pos_data['confidence'],
                'age_seconds': age_seconds,
                'timestamp': pos_data['timestamp'].isoformat()
            })

    return jsonify(positions)

@app.route('/api/node_positions', methods=['GET', 'POST'])
def handle_node_positions():
    """GET: Retourne les positions des nodes. POST: Met √† jour les positions"""
    if request.method == 'POST':
        # Client envoie les positions mises √† jour depuis localStorage
        positions_data = request.get_json()
        if positions_data:
            coap_server.node_positions = positions_data
            print(f"üìç Positions nodes mises √† jour: {len(positions_data)} nodes")
            return jsonify({'success': True, 'count': len(positions_data)})
        return jsonify({'success': False, 'error': 'No data provided'}), 400
    else:
        # Retourner les positions actuelles
        return jsonify(coap_server.node_positions)

# ========== AUDIO LIBRARY API ROUTES ==========

@app.route('/api/audio/catalog')
def get_audio_catalog():
    """Retourne le catalogue audio complet"""
    try:
        stats = audio_lib.get_statistics()
        categories = audio_lib.get_all_categories()

        return jsonify({
            'success': True,
            'statistics': stats,
            'categories': {
                name: {
                    'description': data.get('description'),
                    'count': data.get('count'),
                    'messages': audio_lib.format_for_web(data.get('messages', []))
                }
                for name, data in categories.items()
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/instant')
def get_instant_messages():
    """Retourne les 20 messages instantan√©s prioritaires pour le tertiaire"""
    try:
        instant = audio_lib.get_instant_messages(20)
        formatted = audio_lib.format_for_web(instant)

        return jsonify({
            'success': True,
            'count': len(formatted),
            'messages': formatted
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/category/<category>')
def get_audio_category(category):
    """Retourne tous les messages d'une cat√©gorie"""
    try:
        cat_data = audio_lib.get_category(category)

        if not cat_data:
            return jsonify({
                'success': False,
                'error': f'Category not found: {category}'
            }), 404

        messages = audio_lib.format_for_web(cat_data.get('messages', []))

        return jsonify({
            'success': True,
            'category': category,
            'description': cat_data.get('description'),
            'count': len(messages),
            'messages': messages
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/search')
def search_audio():
    """Recherche de messages audio par mots-cl√©s"""
    keywords = request.args.get('q', '')

    if not keywords:
        return jsonify({
            'success': False,
            'error': 'Missing search query parameter: q'
        }), 400

    try:
        results = audio_lib.search(keywords)
        formatted = audio_lib.format_for_web(results)

        return jsonify({
            'success': True,
            'query': keywords,
            'count': len(formatted),
            'results': formatted
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/play', methods=['POST'])
def play_audio():
    """
    Envoie commande CoAP pour jouer un message audio sur un node

    POST Body:
    {
        "node": "node1",           # Nom du node cible
        "message_id": 5,           # ID du message (optionnel si path fourni)
        "path": "alertes_pti/..."  # Chemin relatif (optionnel si message_id fourni)
    }
    """
    data = request.get_json()

    if not data:
        return jsonify({'success': False, 'error': 'Missing JSON body'}), 400

    node_name = data.get('node')
    message_id = data.get('message_id')
    path = data.get('path')

    if not node_name:
        return jsonify({'success': False, 'error': 'Missing node parameter'}), 400

    if not message_id and not path:
        return jsonify({
            'success': False,
            'error': 'Must provide either message_id or path'
        }), 400

    # R√©cup√©rer l'adresse IPv6 du node
    if node_name not in coap_server.registry.nodes:
        return jsonify({
            'success': False,
            'error': f'Node not found: {node_name}'
        }), 404

    node_data = coap_server.registry.nodes[node_name]
    if isinstance(node_data, dict):
        node_ip = node_data.get('address')
    else:
        node_ip = node_data

    if not node_ip:
        return jsonify({
            'success': False,
            'error': f'Node address not found: {node_name}'
        }), 404

    try:
        # Construire commande CoAP
        if message_id:
            coap_payload = f"play:{message_id}"
            msg_info = audio_lib.get_message_by_id(message_id)
            description = msg_info.get('description', '') if msg_info else ''
        else:
            # ESP32 adds /sdcard/ prefix automatically, send relative path only
            # If path ends with '/', it's a folder - find first WAV file
            if path.endswith('/'):
                import os
                folder_path = f"/Volumes/LUXWAVE/audiowav/{path}"
                if os.path.exists(folder_path) and os.path.isdir(folder_path):
                    wav_files = [f for f in os.listdir(folder_path) if f.lower().endswith('.wav')]
                    if wav_files:
                        wav_files.sort()  # Sort alphabetically to get first track
                        first_track = wav_files[0]
                        coap_payload = f"play:path:{path}{first_track}"
                        description = f"{path}{first_track}"
                    else:
                        return jsonify({
                            'success': False,
                            'error': f'No WAV files found in folder: {path}'
                        }), 404
                else:
                    return jsonify({
                        'success': False,
                        'error': f'Folder not found: {path}'
                    }), 404
            else:
                coap_payload = f"play:path:{path}"
                description = path

        # Envoyer commande via WebSocket ou CoAP selon la configuration
        if USE_WEBSOCKET_BR:
            # Mode WebSocket : envoyer via Border Router avec routing IPv6
            success = native_ws_handler.send_command_to_node(
                node_name,
                'audio',
                coap_payload
            )

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send command via Border Router'
                }), 500

            request_id = None  # IPv6 routing doesn't use request_id
        else:
            # Mode direct CoAP
            success = coap_server.send_coap_post(node_ip, 'audio', coap_payload)
            request_id = None

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send CoAP command'
                }), 500

        # √âmettre √©v√©nement WebSocket pour mise √† jour UI
        socketio.emit('audio_playback', {
            'node': node_name,
            'message_id': message_id,
            'description': description,
            'timestamp': datetime.now().isoformat(),
            'request_id': request_id
        })

        return jsonify({
            'success': True,
            'node': node_name,
            'message': description,
            'request_id': request_id
        })

    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/stop', methods=['POST'])
def stop_audio():
    """Arr√™te la lecture audio sur un node"""
    data = request.get_json()

    node_name = data.get('node')
    if not node_name:
        return jsonify({'success': False, 'error': 'Missing node parameter'}), 400

    if node_name not in coap_server.registry.nodes:
        return jsonify({
            'success': False,
            'error': f'Node not found: {node_name}'
        }), 404

    node_data = coap_server.registry.nodes[node_name]
    if isinstance(node_data, dict):
        node_ip = node_data.get('address')
    else:
        node_ip = node_data

    if not node_ip:
        return jsonify({
            'success': False,
            'error': f'Node address not found: {node_name}'
        }), 404

    try:
        # Envoyer commande via WebSocket ou CoAP selon la configuration
        if USE_WEBSOCKET_BR:
            # Mode WebSocket : envoyer via Border Router avec routing IPv6
            success = native_ws_handler.send_command_to_node(
                node_name,
                'audio',
                'stop'
            )

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send command via Border Router'
                }), 500

            request_id = None  # IPv6 routing doesn't use request_id
        else:
            # Mode direct CoAP
            success = coap_server.send_coap_post(node_ip, 'audio', 'stop')
            request_id = None

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send CoAP command'
                }), 500

        return jsonify({
            'success': True,
            'node': node_name,
            'request_id': request_id
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/audio/volume', methods=['POST'])
def set_audio_volume():
    """R√®gle le volume audio sur un node"""
    data = request.get_json()

    node_name = data.get('node')
    volume = data.get('volume')  # 0-100

    if not node_name or volume is None:
        return jsonify({
            'success': False,
            'error': 'Missing node or volume parameter'
        }), 400

    if not (0 <= volume <= 100):
        return jsonify({
            'success': False,
            'error': 'Volume must be between 0 and 100'
        }), 400

    if node_name not in coap_server.registry.nodes:
        return jsonify({
            'success': False,
            'error': f'Node not found: {node_name}'
        }), 404

    node_data = coap_server.registry.nodes[node_name]
    if isinstance(node_data, dict):
        node_ip = node_data.get('address')
    else:
        node_ip = node_data

    if not node_ip:
        return jsonify({
            'success': False,
            'error': f'Node address not found: {node_name}'
        }), 404

    try:
        # Envoyer commande via WebSocket ou CoAP selon la configuration
        if USE_WEBSOCKET_BR:
            # Mode WebSocket : envoyer via Border Router avec routing IPv6
            success = native_ws_handler.send_command_to_node(
                node_name,
                'audio',
                f'volume:{volume}'
            )

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send command via Border Router'
                }), 500

            request_id = None  # IPv6 routing doesn't use request_id
        else:
            # Mode direct CoAP
            success = coap_server.send_coap_post(node_ip, 'audio', f'volume:{volume}')
            request_id = None

            if not success:
                return jsonify({
                    'success': False,
                    'error': 'Failed to send CoAP command'
                }), 500

        return jsonify({
            'success': True,
            'node': node_name,
            'volume': volume,
            'request_id': request_id
        })
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@socketio.on('connect')
def handle_connect():
    print('Client connect√© au WebSocket')
    emit('connected', {'message': 'Connect√© au serveur CoAP'})
    
    # Envoyer les donn√©es initiales des devices si disponibles
    if coap_server and coap_server.thingsboard.connected:
        for device_name, loc_info in coap_server.thingsboard.device_loc_code.items():
            if loc_info.get('value'):
                emit('loc_code_update', {
                    'device': device_name,
                    'loc_code': loc_info['value'],
                    'timestamp': datetime.now().isoformat()
                })

@socketio.on('disconnect')
def handle_disconnect():
    print('Client d√©connect√© du WebSocket')

@socketio.on('request_devices')
def handle_request_devices():
    """Envoie la liste des devices sur demande"""
    devices_data = []
    
    if coap_server and coap_server.thingsboard.connected:
        for device_name, device_id in coap_server.thingsboard.device_cache.items():
            loc_info = coap_server.thingsboard.device_loc_code.get(device_name, {})
            devices_data.append({
                'name': device_name,
                'id': device_id,
                'loc_code': loc_info.get('value'),
                'timestamp': loc_info.get('timestamp')
            })
    
    emit('devices_list', devices_data)


# ============================================================================
# WebSocket Namespace pour Border Routers (/ws/br)
# ============================================================================

@socketio.on('connect', namespace='/ws/br')
def handle_br_connect():
    """
    G√®re la connexion d'un Border Router via WebSocket
    Query params attendus: br_id, auth_token, network_prefix
    """
    br_id = request.args.get('br_id')
    auth_token = request.args.get('auth_token')
    network_prefix = request.args.get('network_prefix', '')

    if not br_id or not auth_token:
        print("‚ùå Connexion BR refus√©e: br_id ou auth_token manquant")
        return False

    # V√©rifier l'authentification
    if BR_AUTH_ENABLED and not verify_br_token(br_id, auth_token):
        print(f"‚ùå Connexion BR refus√©e: authentification √©chou√©e pour {br_id}")
        return False

    # R√©cup√©rer la config du BR (nodes associ√©s)
    br_config = get_br_config(br_id)
    nodes = br_config.get('nodes', []) if br_config else []

    # Enregistrer le BR dans le manager
    success = border_router_manager.register_br(
        br_id=br_id,
        sid=request.sid,
        network_prefix=network_prefix,
        nodes=nodes
    )

    if success:
        # Joindre la room sp√©cifique au BR
        from flask_socketio import join_room
        join_room(f'br_{br_id}')

        # Envoyer confirmation
        emit('connected', {
            'status': 'ok',
            'br_id': br_id,
            'server_time': time.time(),
            'use_websocket_mode': USE_WEBSOCKET_BR
        })

        print(f"‚úÖ Border Router {br_id} connect√© via WebSocket (sid: {request.sid})")
        return True
    else:
        print(f"‚ùå √âchec enregistrement BR {br_id}")
        return False


@socketio.on('disconnect', namespace='/ws/br')
def handle_br_disconnect():
    """G√®re la d√©connexion d'un Border Router"""
    br_id = border_router_manager.sid_to_br.get(request.sid)

    if br_id:
        border_router_manager.unregister_br(br_id)
        logger.warning(f"‚ö†Ô∏è Border Router {br_id} d√©connect√© (WebSocket)")


@socketio.on('heartbeat', namespace='/ws/br')
def handle_br_heartbeat(data):
    """
    G√®re le heartbeat d'un Border Router
    Data: {br_id, timestamp, nodes_count, status}
    """
    br_id = data.get('br_id')
    nodes_count = data.get('nodes_count', 0)

    if not br_id:
        return

    # Mettre √† jour le heartbeat
    border_router_manager.update_heartbeat(br_id, nodes_count)

    # R√©pondre avec ACK
    emit('heartbeat_ack', {
        'timestamp': time.time(),
        'server_status': 'ok'
    })


@socketio.on('node_event', namespace='/ws/br')
def handle_node_event(data):
    """
    G√®re les √©v√©nements des nodes ESP32 (via BR proxy)
    Data: {type, br_id, node, event_type, payload, timestamp}
    """
    try:
        br_id = data.get('br_id')
        node_name = data.get('node')
        event_type = data.get('event_type')  # 'button', 'battery', 'ble-beacon'
        payload = data.get('payload', {})

        if not br_id or not node_name or not event_type:
            print("√âv√©nement node invalide: champs manquants")
            return

        # Incr√©menter le compteur d'√©v√©nements
        border_router_manager.increment_event_counter(br_id)

        # Router vers les handlers appropri√©s
        if event_type == 'button' and coap_server:
            # Adapter le format pour l'handler existant
            coap_server.handle_button_event_from_br({
                'node': node_name,
                'br_id': br_id,
                'payload': payload
            })

        elif event_type == 'battery' and coap_server:
            coap_server.handle_battery_event_from_br({
                'node': node_name,
                'br_id': br_id,
                'voltage': payload.get('voltage'),
                'percentage': payload.get('percentage')
            })

        elif event_type == 'ble_beacon' and coap_server:
            coap_server.handle_ble_event_from_br({
                'node': node_name,
                'br_id': br_id,
                'payload': payload  # Passer le payload complet
            })

        # √âmettre l'√©v√©nement aux clients web
        socketio.emit('node_event', {
            'node': node_name,
            'br_id': br_id,
            'event_type': event_type,
            'payload': payload,
            'timestamp': time.time()
        }, namespace='/')

    except Exception as e:
        print(f"Erreur traitement √©v√©nement node: {e}")


@socketio.on('command_response', namespace='/ws/br')
def handle_command_response(data):
    """
    G√®re la r√©ponse √† une commande envoy√©e √† un node
    Data: {br_id, request_id, node, status, result, error}
    """
    try:
        br_id = data.get('br_id')
        request_id = data.get('request_id')
        node_name = data.get('node')
        status = data.get('status')  # 'success' ou 'error'
        result = data.get('result', {})
        error = data.get('error')

        if not request_id:
            return

        # Notifier les clients web
        socketio.emit('command_completed', {
            'request_id': request_id,
            'node': node_name,
            'br_id': br_id,
            'status': status,
            'result': result,
            'error': error,
            'timestamp': time.time()
        }, namespace='/')

        print(f"üì® R√©ponse commande {request_id}: {status} (node: {node_name}, BR: {br_id})")

    except Exception as e:
        print(f"Erreur traitement r√©ponse commande: {e}")


@socketio.on('topology_update', namespace='/ws/br')
def handle_topology_update(data):
    """
    G√®re la mise √† jour de topologie envoy√©e par un BR
    Data: {br_id, nodes: [{name, rloc16, role, ...}]}
    """
    try:
        br_id = data.get('br_id')
        nodes = data.get('nodes', [])

        if not br_id:
            return

        # Extraire les noms des nodes
        node_names = [n.get('name') for n in nodes if n.get('name')]

        # Mettre √† jour la liste des nodes du BR
        border_router_manager.update_nodes_list(br_id, node_names)

        print(f"üó∫Ô∏è Topologie mise √† jour pour BR {br_id}: {len(node_names)} nodes")

        # Notifier les clients web
        socketio.emit('topology_update', {
            'br_id': br_id,
            'nodes_count': len(node_names)
        }, namespace='/')

    except Exception as e:
        print(f"Erreur mise √† jour topologie: {e}")


# ============================================================================
# NATIVE WEBSOCKET ENDPOINT (without Socket.IO) for ESP32 Border Routers
# ============================================================================

@sock.route('/ws/br')
def border_router_websocket(ws):
    """
    Native WebSocket endpoint for ESP32 Border Router clients

    This endpoint handles plain WebSocket connections (without Socket.IO)
    for ESP32 devices using esp_websocket_client library.

    URL format:
        ws://server:port/ws/br?br_id=BR-001&auth_token=xxx&network_prefix=fd78::/64

    Messages are exchanged in plain JSON format:
        - Client -> Server: {"type": "heartbeat", "br_id": "BR-001", ...}
        - Server -> Client: {"type": "command", "target_node": "n01", ...}
    """
    from flask import request
    native_ws_handler.handle_connection(ws, request.environ)


def run_web_server():
    """Lance le serveur web dans un thread s√©par√©"""
    print(f"üåê Interface web disponible sur http://localhost:{WEB_PORT}")
    print(f"   Backend: threading (async_mode='threading')")
    socketio.run(app, host='0.0.0.0', port=WEB_PORT, debug=False, use_reloader=False, allow_unsafe_werkzeug=True)

def main():
    """Fonction principale"""
    global coap_server

    print("üöÄ Fonction main() appel√©e")

    # Cr√©er fichier exemple si n√©cessaire
    if not Path(ADDRESSES_FILE).exists():
        example_data = {
            "nodes": {
                "node_1": "fde7:cfa3:40ca:73b5:xxxx:xxxx:xxxx:xxx1",
                "node_2": "fde7:cfa3:40ca:73b5:xxxx:xxxx:xxxx:xxx2"
            }
        }
        with open(ADDRESSES_FILE, 'w') as f:
            json.dump(example_data, f, indent=2)
        print(f"üìù Fichier {ADDRESSES_FILE} cr√©√© avec des exemples")
        print("‚ö†Ô∏è  Remplacez les adresses par les vraies adresses IPv6 de vos nodes!")
        print()

    # Obtenir ou cr√©er le serveur CoAP (lazy initialization dans get_coap_server)
    # Cela fonctionne m√™me si le module est import√© plusieurs fois par les workers Flask
    coap_server = get_coap_server()
    print(f"‚úÖ CoAP Server disponible: {coap_server} (id={id(coap_server)})")

    # Initialiser le handler WebSocket natif avec les bonnes r√©f√©rences
    # Cela √©vite les imports circulaires et assure qu'on utilise la M√äME instance de socketio
    from lib import native_websocket_handler
    native_websocket_handler.init(
        app=app,
        socketio=socketio,
        coap_server=coap_server,
        border_router_manager=border_router_manager
    )

    # Lancer le serveur web dans un thread
    web_thread = threading.Thread(target=run_web_server)
    web_thread.daemon = True
    web_thread.start()

    # Mode WebSocket BR : pas de serveur CoAP direct, pas de scan topologie
    if USE_WEBSOCKET_BR:
        print("=" * 60)
        print("üîÑ MODE WEBSOCKET BORDER ROUTER ACTIV√â")
        print("=" * 60)
        print("üì° Le serveur attend les connexions WebSocket des Border Routers")
        print("   Endpoint: ws://0.0.0.0:5001/ws/br")
        print("üö´ Serveur CoAP direct d√©sactiv√© (proxy via BR)")
        print("üö´ Scan topologie Thread d√©sactiv√© (topologie via BR)")
        print("=" * 60)
        print()

        # Boucle simple pour garder le programme actif
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nüëã Arr√™t du serveur...")

    # Mode CoAP direct : lancer le serveur CoAP et le scan topologie
    else:
        print("=" * 60)
        print("üîÑ MODE COAP DIRECT ACTIV√â")
        print("=" * 60)
        print("üì° Le serveur communique directement avec les nodes Thread")
        print("‚úÖ Serveur CoAP en √©coute sur port 5683")
        print("‚úÖ Scan topologie Thread activ√©")
        print("=" * 60)
        print()

        # Lancer le scan initial de la topologie dans un thread
        print("üó∫Ô∏è  D√©marrage du scan initial de la topologie...")
        topology_thread = threading.Thread(target=refresh_topology_background)
        topology_thread.daemon = True
        topology_thread.start()

        # Lancer le serveur CoAP (boucle bloquante)
        coap_server.run()

if __name__ == "__main__":
    main()